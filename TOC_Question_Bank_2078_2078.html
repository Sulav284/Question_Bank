
    <html>
    <head>
        <meta charset="UTF-8">
        <title>TOC Question Bank 2078 2078</title>
    </head>
    <body>
        <h1>TOC Question Bank 2078 - 2078</h1>
        <p><strong>Full Marks:</strong> 60 + 20 + 20</p>
        <p><strong>Pass Marks:</strong> 24 + 8 + 8</p>
        <p><strong>Time:</strong> 3 hours</p>
    <h2>Long Answer Questions: Attempt any two Questions (2 x 10 = 20)</h2><h3>Question 1</h3>
<div><p><p>Give the formal definition of DFA and NFA. How NFA can be converted into eqivalent DFA? Explain with suitable example.</p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p>A DFA is a finite automation consisting of five tuples: (Q, Σ, δ, q0, F) where:</p>
<ul style="list-style-type: square;">
<li>Q is a finite set of states.</li>
<li>Σ is a finite set of symbols called the alphabet.</li>
<li>δ is the transition function where δ: Q × Σ → Q</li>
<li>q0 is the initial state from where any input is processed (q0 ∈ Q).</li>
<li>F is a set of final state/states of Q (F ⊆ Q).</li>
</ul>
<p>An NFA is finite automation consisting of five tuples: (Q, Σ, δ, q0, F) where:</p>
<ul style="list-style-type: square;">
<li>Q is a finite set of states.</li>
<li>Σ is a finite set of symbols called the alphabet.</li>
<li>δ is the transition function where δ: Q × Σ → 2^Q (Here the power set of Q (2^Q) has been taken because in case of NDFA, from a state, transition can occur to any combination of Q states)</li>
<li>q0 is the initial state from where any input is processed (q0 ∈ Q).</li>
<li>F is a set of final state/states of Q (F ⊆ Q).</li>
</ul>
<p><span style="text-decoration: underline;"><strong>Conversion from NFA to DFA:</strong></span></p>
<p>Suppose there is an NFA N &lt; Q, ∑, q0, δ, F &gt; that recognizes a language L. Then the DFA D &lt; Q’, ∑, q0, δ’, F’ &gt; can be constructed for language L as:</p>
<p>Step 1: Initially Q’ = ɸ.</p>
<p>Step 2: Add q0 to Q’.</p>
<p>Step 3: For each state in Q’, find the possible set of states for each input symbol using the transition function of NFA. If this set of states is not in Q’, add it to Q’.</p>
<p>Step 4: Final state of DFA will be all states containing F (final states of NFA)</p>
<p><strong>Example</strong><br />
Consider the following NFA shown in Figure 1.<br />
<img data-recalc-dims="1" height="0" width="0" decoding="async" class="aligncenter size-medium wp-image-178751" src="https://i0.wp.com/media.geeksforgeeks.org/wp-content/cdn-uploads/nfatofdfa_Figure1.png?fit=0%2C0&#038;ssl=1" sizes="(max-width: 578px) 100vw, 578px" srcset="https://www.geeksforgeeks.org/wp-content/uploads/nfatofdfa_Figure1.png 578w, https://www.geeksforgeeks.org/wp-content/uploads/nfatofdfa_Figure1-300x108.png 300w" alt=""><br />
The following are the various parameters for NFA.</p>
<p>Q = { q0, q1, q2 }<br />
∑ = ( a, b )<br />
F = { q2 }</p>
<p>δ (Transition Function of NFA)<br />
<img data-recalc-dims="1" decoding="async" class="aligncenter size-full wp-image-178757" src="https://i0.wp.com/media.geeksforgeeks.org/wp-content/cdn-uploads/nfatofdfa_table1.png?ssl=1" alt=""></p>
<p>Step 1: Q’ = ɸ<br />
Step 2: Q’ = {q0}<br />
Step 3: For each state in Q’, find the states for each input symbol.</p>
<p>Currently, a state in Q’ is q0, find moves from q0 on input symbols a and b using the transition function of NFA and update the transition table of DFA.</p>
<p>δ’ (Transition Function of DFA)<br />
<img data-recalc-dims="1" decoding="async" class="aligncenter size-full wp-image-178758" src="https://i0.wp.com/media.geeksforgeeks.org/wp-content/cdn-uploads/nfatofdfa_table2.png?ssl=1" alt=""><br />
Now { q0, q1 } will be considered as a single state. As its entry is not in Q’, add it to Q’.</p>
<p>So Q’ = { q0, { q0, q1 } }</p>
<p>Now, moves from state { q0, q1 } on different input symbols are not present in the transition table of DFA,</p>
<p>we will calculate it like this:</p>
<p>δ’ ( { q0, q1 }, a ) = δ ( q0, a ) ∪ δ ( q1, a ) = { q0, q1 }</p>
<p>δ’ ( { q0, q1 }, b ) = δ ( q0, b ) ∪ δ ( q1, b ) = { q0, q2 }</p>
<p>Now we will update the transition table of DFA.</p>
<p>δ’ (Transition Function of DFA)<br />
<img data-recalc-dims="1" decoding="async" class="aligncenter size-full wp-image-178759" src="https://i0.wp.com/media.geeksforgeeks.org/wp-content/cdn-uploads/nfatofdfa_table3.png?ssl=1" alt=""><br />
Now { q0, q2 } will be considered as a single state. As its entry is not in Q’, add it to Q’.</p>
<p>So Q’ = { q0, { q0, q1 }, { q0, q2 } }</p>
<p>Now, moves from state {q0, q2} on different input symbols are not present in the transition table of</p>
<p>DFA, we will calculate it like:</p>
<p>δ’ ( { q0, q2 }, a ) = δ ( q0, a ) ∪ δ ( q2, a ) = { q0, q1 }</p>
<p>δ’ ( { q0, q2 }, b ) = δ ( q0, b ) ∪ δ ( q2, b ) = { q0 }</p>
<p>Now we will update the transition table of DFA.</p>
<p>δ’ (Transition Function of DFA)<br />
<img data-recalc-dims="1" decoding="async" class="aligncenter size-full wp-image-178760" src="https://i0.wp.com/media.geeksforgeeks.org/wp-content/cdn-uploads/nfatofdfa_table4.png?ssl=1" sizes="(max-width: 287px) 100vw, 287px" srcset="https://www.geeksforgeeks.org/wp-content/uploads/nfatofdfa_table4.png 287w, https://www.geeksforgeeks.org/wp-content/uploads/nfatofdfa_table4-200x140.png 200w" alt=""><br />
As there is no new state generated, we are done with the conversion. The final state of DFA will be state which has q2 as its component i.e., { q0, q2 }</p>
<p>The following are the various parameters for DFA.<br />
Q’ = { q0, { q0, q1 }, { q0, q2 } }<br />
∑ = ( a, b )<br />
F = { { q0, q2 } } and transition function δ’ as shown above. The final DFA for the above NFA has been shown in Figure 2.<br />
<img data-recalc-dims="1" height="0" width="0" decoding="async" class="aligncenter size-medium wp-image-178752" src="https://i0.wp.com/media.geeksforgeeks.org/wp-content/cdn-uploads/nfatofdfa_Figure2.png?fit=0%2C0&#038;ssl=1" sizes="(max-width: 553px) 100vw, 553px" srcset="https://www.geeksforgeeks.org/wp-content/uploads/nfatofdfa_Figure2.png 553w, https://www.geeksforgeeks.org/wp-content/uploads/nfatofdfa_Figure2-300x157.png 300w" alt=""></p>
</div>
<h3>Question 2</h3>
<div><p><p>Find the minimum state DFA for the given DFA below:</p>
<div class="table_wrapper"><table>
<tbody>
<tr>
<td rowspan="2">States</td>
<td colspan="2">Input</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>A</td>
<td>B</td>
<td>F</td>
</tr>
<tr>
<td>B</td>
<td>E</td>
<td>C</td>
</tr>
<tr>
<td>C</td>
<td>B</td>
<td>D</td>
</tr>
<tr>
<td>*D</td>
<td>E</td>
<td>F</td>
</tr>
<tr>
<td>E</td>
<td>B</td>
<td>C</td>
</tr>
<tr>
<td>F</td>
<td>B</td>
<td>A</td>
</tr>
</tbody>
</table></div</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p><img data-recalc-dims="1" loading="lazy" decoding="async" class="alignnone size-full wp-image-7090" src="https://i0.wp.com/hamrocsit.com/wp-content/uploads/2022/08/download-20-min-scaled.jpg?resize=1886%2C2560&#038;ssl=1" alt="" width="1886" height="2560"> <img data-recalc-dims="1" loading="lazy" decoding="async" class="alignnone size-medium wp-image-7091" src="https://i0.wp.com/hamrocsit.com/wp-content/uploads/2022/08/download-21-min.jpg?resize=2125%2C1212&#038;ssl=1" alt="" width="2125" height="1212"></p>
</div>
<h3>Question 3</h3>
<div><p><p>Construct a Turing Machine that accepts the language of odd length strings over alphabet {a, b}. Give the complete encoding for this TM as well as its input string w = abb in binary alphabet that is recognized by Universal Turing Machine.</p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p><img data-recalc-dims="1" loading="lazy" decoding="async" class="alignnone size-full wp-image-7093" src="https://i0.wp.com/hamrocsit.com/wp-content/uploads/2022/08/download-22.jpg?resize=2452%2C2173&#038;ssl=1" alt="" width="2452" height="2173"> <img data-recalc-dims="1" loading="lazy" decoding="async" class="alignnone size-medium wp-image-7094" src="https://i0.wp.com/hamrocsit.com/wp-content/uploads/2022/08/download-23-scaled.jpg?resize=1773%2C2560&#038;ssl=1" alt="" width="1773" height="2560"></p>
</div>
<h2>Short Answer Questions: Attempt any Eight Questions</h2><h3>Question 4</h3>
<div><p><p>Define the term alphabet, prefix and suffix of string, concatenation and Kleen closure with example.</p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p><span style="text-decoration: underline;"><strong>Alphabet:</strong></span></p>
<p>An alphabet is a finite non-empty set of symbols. The symbols can be the letters such as {a, b, c}, bits {0, 1} digits {0, 1, 2 &#8230; 9}, common characters like $, #, * etc</p>
<p>For example:</p>
<p>Σ = {0, 1} → Binary alphabets</p>
<p>Σ = {+, -, *} → Special symbols</p>
<p><span style="text-decoration: underline;"><strong>Prefix of String:</strong></span></p>
<p>A string is called a prefix of a string w if it is obtained by remaining zero or more trailing symbols of w.</p>
<p>For example:</p>
<p>w = abcd</p>
<p>s = abc is the prefix of w</p>
<p>s is the proper prefix if s<strong> ≠ </strong>w</p>
<p><span style="text-decoration: underline;"><strong>Suffix of String:</strong></span></p>
<p>A string is called a suffix of a string w if it is obtained by remaining zero or more leading symbols in w.</p>
<p>For example:</p>
<p>w = abcd</p>
<p>s = bcd is the suffix of w</p>
<p>s is the proper suffix if s<strong> ≠ </strong>w</p>
<p><span style="text-decoration: underline;"><strong>Concatenation of Strings:</strong></span></p>
<p>If x and y are two strings over an alphabet, concatenation of x and y is written xy and x consists of the symbols of x followed by those of y.</p>
<p>For example:</p>
<p>x = aaa</p>
<p>y = bbb</p>
<p>xy = aaabbb</p>
<p>yx = bbbaaa</p>
<p><span style="text-decoration: underline;"><strong>Kleen Closure:</strong></span></p>
<p>The set of all strings over an alphabet Σ is called Kleen closure of Σ and is denoted by Σ<sup>*</sup>, Thus Kleen closure is set of all strings over alphabet Σ length 0 or more.</p>
<p>Σ<sup>*</sup> = Σ0 U Σ<sup>1</sup> U Σ<sup>2</sup> U Σ<sup>3</sup> . . .</p>
<p>E.g: A = {0}</p>
<p>A<sup>*</sup> = \(\left \{ \frac{0^n}{n = 0, 1, 2 . . .} \right \}\)</p>
</div>
<h3>Question 5</h3>
<div><p><p>Give the regular expressions for the following language over alphabet {a, b}.</p>
<ol>
<li>Set of all strings with substring bab or abb.</li>
<li>Set of all strings whose 3<sup>rd</sup> symbol is ‘a’ and 5<sup>th</sup> symbol is ‘b’.</li>
</ol</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p>Given</p>
<p>Σ = {a, b}</p>
<p>a) Regular Expression for a set of strings with substring bab or aab is</p>
<p>(a+b)*bab(a+b)*+(a+b)*aab(a+b)*</p>
<p>b) Regular expression for a set of strings whose 3rd symbol is &#8216;a&#8217; and 5th symbol is &#8216;b&#8217; is</p>
<p>(a+b)(a+b)a(a+b)b(a+b)*</p>
</div>
<h3>Question 6</h3>
<div><p><p>Show that L = { a<sup>n</sup> | n is a prime number } is not a regular language.</p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p>Suppose n=k;</p>
<p><strong>Proof by contradiction:</strong><br />
Let us assume L is regular. Clearly L is infinite (there are infinitely many prime numbers). From the pumping lemma, there exists a number n such that any string w of length greater than n has a “repeatable” substring generating more strings in the language L. Let us consider the first prime number p ≥ n.</p>
<p>From the pumping lemma the string of length p has a “repeatable” substring. We will assume that this substring is of length k ≥ 1. Hence:</p>
<p>a<sup>p</sup> ∈L         and</p>
<p>a<sup>p</sup> <sup>+ k </sup>∈L   as well as</p>
<p>a<sup>p+2k</sup>  ∈ L, etc.<br />
It should be relatively clear that p + k, p + 2k, etc., cannot all be prime but let us add k p times, then we must have:</p>
<p>a<sup>p + pk </sup>∈L, of course a<sup>p + pk </sup>= a<sup>p (k + 1)</sup></p>
<p>so this would imply that (k + 1)p is prime, which it is not since it is divisible by both p and k + 1.<br />
Hence L is not regular.</p>
</div>
<h3>Question 7</h3>
<div><p><p>Explain about the Chomsky’s Hierarchy about the language and programs.</p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p>According to Chomsky&#8217;s hierarchy, grammar is divided into 4 types as follows:</p>
<ol style="list-style-type:decimal;">
<li>Type 0 is known as unrestricted grammar.</li>
<li>Type 1 is known as context-sensitive grammar.</li>
<li>Type 2 is known as context-free grammar.</li>
<li>Type 3 Regular Grammar.</li>
</ol>
<p><img data-recalc-dims="1" decoding="async" class="aligncenter" src="https://i0.wp.com/media.geeksforgeeks.org/wp-content/cdn-uploads/20210407173848/12312.png?ssl=1" alt=""></p>
<p><strong>Type 0: Unrestricted Grammar: </strong></p>
<p>Type-0 grammars include all formal grammar. Type 0 grammar languages are recognized by the touring machine. These languages are also known as the Recursively Enumerable languages.</p>
<p>Grammar Production in the form of   <strong><b>α ⟶ β</b></strong> where</p>
<pre class="EnlighterJSRAW" data-enlighter-language="generic">α is ( V + T)* V ( V + T)* 

V : Variables 
T : Terminals.</pre>
<pre class="EnlighterJSRAW" data-enlighter-language="generic">β is ( V + T )*</pre>
<p>In type 0 there must be at least one variable on the Left side of production.</p>
<p>For example:</p>
<pre class="EnlighterJSRAW" data-enlighter-language="generic">Sab --&gt; ba 
A --&gt; S</pre>
<p>Here, Variables are S, A, and Terminals a, b.</p>
<p><strong>Type 1: </strong>Context-Sensitive Grammar</p>
<p>Type-1 grammars generate context-sensitive languages. The language generated by the grammar is recognized by the Linear Bound Automata</p>
<p>In Type 1</p>
<ul style="list-style-type: square;">
<li>First of all Type 1 grammar should be Type 0.</li>
<li>Grammar Production in the form of</li>
</ul>
<pre class="EnlighterJSRAW" data-enlighter-language="generic">α ⟶ β
α &lt;= β</pre>
<p>&nbsp;</p>
<p>That is the count of symbols in α is less than or equal to β</p>
<p>Also β  ∈ (V + T)<sup>+</sup></p>
<p>i.e. β can not be ε</p>
<p>For Example:</p>
<pre class="EnlighterJSRAW" data-enlighter-language="generic">S --&gt; AB
AB --&gt; abc 
B --&gt; b</pre>
<p><strong>Type 2: Context-Free Grammar:</strong> Type-2 grammars generate context-free languages. The language generated by the grammar is recognized by Pushdown automata.  In Type 2:</p>
<ul style="list-style-type: square;">
<li>First of all, it should be Type 1.</li>
<li>The left-hand side of production can have only one variable and there is no restriction on β</li>
</ul>
<p>| α | = 1.</p>
<p>For example:</p>
<pre class="EnlighterJSRAW" data-enlighter-language="generic">S --&gt; AB  
A --&gt; a  
B --&gt; b</pre>
<p><strong>Type 3: Regular Grammar: </strong>Type-3 grammars generate regular languages. These languages are exactly all languages that can be accepted by a finite-state automaton. Type 3 is the most restricted form of grammar.</p>
<p>Type 3 should be in the given form only :</p>
<pre class="EnlighterJSRAW" data-enlighter-language="generic">V --&gt; VT / T          (left-regular grammar)
(or)
V --&gt; TV /T          (right-regular grammar)</pre>
<p>For example:</p>
<pre class="EnlighterJSRAW" data-enlighter-language="generic">S --&gt; a</pre>
<p>The above form is called strictly regular grammar.</p>
<p>There is another form of regular grammar called extended regular grammar. In this form:</p>
<pre class="EnlighterJSRAW" data-enlighter-language="generic">V --&gt; VT* / T*.        (extended left-regular grammar)
(or) 
V --&gt; T*V /T*          (extended right-regular grammar)</pre>
<p>For example :</p>
<pre class="EnlighterJSRAW" data-enlighter-language="generic">S --&gt; ab</pre>
</div>
<h3>Question 8</h3>
<div><p><p>Define a Push Down Automata. Construct a PDA that accepts L = {a<sup>n</sup>b<sup>n</sup> | n > 0}</p>
<p> </p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p>Pushdown Automata is a finite automata with extra memory called stack which helps Pushdown automata to recognize Context Free Languages.</p>
<p>A Pushdown Automata (PDA) can be defined as :</p>
<div id="GFG_AD_gfg_mobile_336x280"></div>
<ul style="list-style-type: square;">
<li>Q is the set of states</li>
<li>∑is the set of input symbols</li>
<li>Γ is the set of pushdown symbols (which can be pushed and popped from stack)</li>
<li>q0 is the initial state</li>
<li>Z is the initial pushdown symbol (which is initially present in stack)</li>
<li>F is the set of final states</li>
<li>δ is a transition function which maps Q x {Σ ∪ ∈} x Γ into Q x Γ*. In a given state, PDA will read input symbol and stack symbol (top of the stack) and move to a new state and change the symbol of stack.</li>
</ul>
<h3>Solution</h3>
<p><img data-recalc-dims="1" loading="lazy" decoding="async" class="alignnone  wp-image-35866 aligncenter" src="https://i0.wp.com/hamrocsit.com/wp-content/uploads/2022/04/pda.drawio.png?resize=302%2C196&#038;ssl=1" alt="" width="302" height="196"></p>
<p>This language accepts L = {ε, 01, 0011, 000111, &#8230;&#8230;&#8230;&#8230;&#8230;&#8230;&#8230;&#8230;&#8230;.. }</p>
<p>Here, in this example, the number of <b>‘a’</b> and <b>‘b’</b> have to be same.</p>
<ul class="list">
<li>Initially we put a special symbol <b>‘$’</b> into the empty stack.</li>
<li>Then at state <b>q<sub>2</sub></b>, if we encounter input 0 and top is Null, we push 0 into stack. This may iterate. And if we encounter input 1 and top is 0, we pop this 0.</li>
<li>Then at state <b>q<sub>3</sub></b>, if we encounter input 1 and top is 0, we pop this 0. This may also iterate. And if we encounter input 1 and top is 0, we pop the top element.</li>
<li>If the special symbol ‘$’ is encountered at top of the stack, it is popped out and it finally goes to the accepting state q<sub>4</sub>.</li>
</ul>
</div>
<h3>Question 9</h3>
<div><p><p>Construct the following grammer into Chomsky Normal Form.</p>
<p>S → abSb | a | aAb</p>
<p>A → bS | aAAb | ε</p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p><img data-recalc-dims="1" loading="lazy" decoding="async" class="alignnone size-full wp-image-7096" src="https://i0.wp.com/hamrocsit.com/wp-content/uploads/2022/08/download-24-min-scaled.jpg?resize=1994%2C2560&#038;ssl=1" alt="" width="1994" height="2560"> <img data-recalc-dims="1" loading="lazy" decoding="async" class="alignnone size-medium wp-image-7097" src="https://i0.wp.com/hamrocsit.com/wp-content/uploads/2022/08/download-25-min-scaled.jpg?resize=1976%2C2560&#038;ssl=1" alt="" width="1976" height="2560"></p>
</div>
<h3>Question 10</h3>
<div><p><p>Define Turing Machine and explain its different variations.</p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p>A Turing Matchine can be formally described as a 7-tuple (Q, X, ∑, δ, q<sub>0</sub>, B, F) where −</p>
<ul class="list">
<li><b>Q</b> is a finite set of states</li>
<li><b>X</b> is the tape alphabet</li>
<li><b>∑</b> is the input alphabet</li>
<li><b>δ</b> is a transition function; δ : Q × X → Q × X × {Left_shift, Right_shift}.</li>
<li><b>q<sub>0</sub></b> is the initial state</li>
<li><b>B</b> is the blank symbol</li>
<li><b>F</b> is the set of final states</li>
</ul>
<p>Turing machines (TM) can also be deterministic or non-deterministic, but this does not make them any more or less powerful. However, if the tape is restricted so that you can only see the use of the part of the tape with the input, the TM becomes less powerful (linear bounded automata) and can only recognize context-sensitive languages.</p>
<p><strong>1. Multiple-track Turing Machine:</strong></p>
<ul style="list-style-type: square;">
<li>A k-track Turing machine(for some k&gt;0) has k-tracks and one R/W head that reads and writes all of them one by one.</li>
<li>A k-track Turing Machine can be simulated by a single-track Turing machine</li>
</ul>
<p><strong>2. Two-way infinite Tape Turing Machine:</strong></p>
<ul style="list-style-type: square;">
<li>Infinite tape of two-way infinite tape Turing machine is unbounded in both directions left and right.</li>
<li>A two-way infinite tape Turing machine can be simulated by a one-way infinite Turing machine(standard Turing machine).</li>
</ul>
<p><strong>3. Multi-tape Turing Machine:</strong></p>
<ul style="list-style-type: square;">
<li>It has multiple tapes and is controlled by a single head.</li>
<li>The Multi-tape Turing machine is different from the k-track Turing machine but expressive power is the same.</li>
<li>Multi-tape Turing machine can be simulated by a single-tape Turing machine.</li>
</ul>
<p><strong>4. Multi-tape Multi-head Turing Machine:</strong></p>
<ul style="list-style-type: square;">
<li>The multi-tape Turing machine has multiple tapes and multiple heads</li>
<li>Each tape is controlled by a separate head</li>
<li>A multi-Tape Multi-head Turing machine can be simulated by a standard Turing machine.</li>
</ul>
<p><strong>5. Multi-dimensional Tape Turing Machine:</strong></p>
<ul style="list-style-type: square;">
<li>It has multi-dimensional tape where the head can move in any direction that is left, right, up or down.</li>
<li>Multi-dimensional tape Turing machine can be simulated by a one-dimensional Turing machine</li>
</ul>
<p><strong>6. Multi-head Turing Machine:</strong></p>
<ul style="list-style-type: square;">
<li>A multi-head Turing machine contains two or more heads to read the symbols on the same tape.</li>
<li>In one step all the heads since the scanned symbols and move or write independently.</li>
<li>Multi-head Turing machines can be simulated by a single-head Turing machine.</li>
</ul>
<p><strong>7. Non-deterministic Turing Machine:</strong></p>
<ul style="list-style-type: square;">
<li>A non-deterministic Turing machine has a single, one-way infinite tape.</li>
<li>A given state and input symbol has at least one choice to move (a finite number of choices for the next move), and each choice has several choices of the path that it might follow for a given input string.</li>
<li>A non-deterministic Turing machine is equivalent to a deterministic Turing machine.</li>
</ul>
</div>
<h3>Question 11</h3>
<div><p><p>Whar do you mean by computational Complexity? Explian about the time and space complexity of a Turing machine.</p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p>Computational complexity is a computer science concept that focuses on the amount of computing resources needed for particular kinds of tasks. In computational complexity theory, researchers assess the kinds of resources that will be needed for a given type or class of task in order to classify different kinds of tasks into various levels of complexity</p>
<p>A Turing Machine (TM) is a mathematical model which consists of an infinite length tape divided into cells on which input is given. It consists of a head which reads the input tape. A state register stores the state of the Turing machine. After reading an input symbol, it is replaced with another symbol, its internal state is changed, and it moves from one cell to the right or left. If the TM reaches the final state, the input string is accepted, otherwise rejected.</p>
<p>A TM can be formally described as a 7-tuple (Q, X, ∑, δ, q<sub>0</sub>, B, F) where −</p>
<ul class="list">
<li><b>Q</b> is a finite set of states</li>
<li><b>X</b> is the tape alphabet</li>
<li><b>∑</b> is the input alphabet</li>
<li><b>δ</b> is a transition function; δ : Q × X → Q × X × {Left_shift, Right_shift}.</li>
<li><b>q<sub>0</sub></b> is the initial state</li>
<li><b>B</b> is the blank symbol</li>
<li><b>F</b> is the set of final states</li>
</ul>
<h2>Time and Space Complexity of a Turing Machine</h2>
<p>For a Turing machine, the time complexity refers to the measure of the number of times the tape moves when the machine is initialized for some input symbols and the space complexity is the number of cells of the tape written.</p>
<p>Time complexity all reasonable functions −</p>
<p><b>T(n) = O(n log n)</b></p>
<p>TM&#8217;s space complexity −</p>
<p><b>S(n) = O(n)</b></p>
</div>
<h3>Question 12</h3>
<div><p><p>Explain the term Intractability. Is SAT problem is intractable? Justify</p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p>Intractability is a technique for solving problems not to be solvable in polynomial time. The problem that can be solved within a reasonable time and space constraints is called tractable.</p>
</div>
</body></html>