
    <html>
    <head>
        <meta charset="UTF-8">
        <title>OS Question Bank 2080 (new) 2080</title>
    </head>
    <body>
        <h1>OS Question Bank 2080 (new) - 2080</h1>
        <p><strong>Full Marks:</strong> 60 + 20 + 20</p>
        <p><strong>Pass Marks:</strong> 24 + 8 + 8</p>
        <p><strong>Time:</strong> 3 hours</p>
    <h2>SECTION A: Attempt any TWO question.</h2><h3>Question 1</h3>
<div><p><p>How DMA operation is performed? Consider a disk with 200 tracks and the queue has random requests from different processes in the order : 45, 48, 29, 17, 80, 150, 28 and 188. Find the seek time using FIFO, SSTF and SCAN. Assume the initial position of head as 100.</p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p>Direct memory access (DMA) is a method that allows an input/output (I/O) device to send or receive data directly to or from the main memory, bypassing the CPU to speed up memory operations. The process is managed by a chip known as a DMA controller (DMAC).</p>
<p dir="ltr">DMA  are used to communicate data between the peripheral device and the system memory. All four system resources rely on certain lines on a bus. Some lines on the bus are used for IRQs, some for addresses (the I/O addresses and the memory address) and some for DMA .</p>
<p dir="ltr">A DMA  enables a device to transfer data without exposing the CPU to a work overload. Without the DMA , the CPU copies every piece of data using a peripheral bus from the I/O device. Using a peripheral bus occupies the CPU during the read/write process and does not allow other work to be performed until the operation is completed With DMA, the CPU can process other tasks while data transfer is being performed. The transfer of data is first initiated by the CPU. The data block can be transferred to and from memory by the DMAC in three ways.</p>
<p dir="ltr">In burst mode, the system bus is released only after the data transfer is completed. In cycle stealing mode, during the transfer of data between the DMA  and I/O device, the system bus is relinquished for a few clock cycles so that the CPU can perform other tasks. When the data transfer is complete, the CPU receives an interrupt request from the DMA controller. In transparent mode, the DMAC can take charge of the system bus only when it is not required by the processor. However, using a DMA controller might cause cache coherency problems. The data stored in RAM accessed by the DMA controller may not be updated with the correct cache data if the CPU is using external memory. Solutions include flushing cache lines before starting outgoing DMA transfers, or performing a cache invalidation on incoming DMA transfers when external writes are signaled to the cache controller.</p>
<p dir="ltr"><span style="text-decoration: underline;"><strong>Numerical Part</strong></span></p>
<p dir="ltr">for given process, FIFO will be as:</p>
<p dir="ltr"><img data-recalc-dims="1" loading="lazy" decoding="async" class="wp-image-36472 aligncenter" style="text-align: center;" src="https://i0.wp.com/hamrocsit.com/wp-content/uploads/2024/05/FCFS1.drawio.png?resize=731%2C297&#038;ssl=1" alt="" width="731" height="297">Total seek time = (100-45)+(48-45)+(48-29)+(29-17)+(80-17)+(150-80)+(150-28)+(188-28)</p>
<p dir="ltr">                           =55+3+19+12+63+70+122+160</p>
<p dir="ltr">                           =504</p>
<p dir="ltr">
<p dir="ltr">for given process, SSTF will be as:</p>
<p dir="ltr" style="text-align: center;"><img data-recalc-dims="1" loading="lazy" decoding="async" class="alignnone size-full wp-image-36473" src="https://i0.wp.com/hamrocsit.com/wp-content/uploads/2024/05/SSTC.drawio.png?resize=740%2C221&#038;ssl=1" alt="" width="740" height="221"></p>
<p dir="ltr">Total seek time = (100-80)+(80-48)+(48-45)+(45-29)+(29-28)+(28-17)+(150-17)+(188-150)</p>
<p dir="ltr">                           = 20+32+3+16+1+11+133+38</p>
<p dir="ltr">                           = 254</p>
<p dir="ltr">
<p dir="ltr">for given process, SCAN will be as:</p>
<p dir="ltr" style="text-align: center;"><img data-recalc-dims="1" loading="lazy" decoding="async" class="alignnone size-full wp-image-36474" src="https://i0.wp.com/hamrocsit.com/wp-content/uploads/2024/05/SCAN.drawio.png?resize=740%2C251&#038;ssl=1" alt="" width="740" height="251"></p>
<p dir="ltr">Total seek time = (100-80)+(80-48)+(48-45)+(45-29)+(29-28)+(28-17)+(17-0)+(150-0)+(188-150)</p>
<p dir="ltr">                           = 20+32+3+16+1+11+17+150+38</p>
<p dir="ltr">                           = 288</p>
</div>
<h3>Question 2</h3>
<div><p><p>How do you distinguish between deadlock and starvation ? Describec. Explain working mechanism of TLB.</p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p>Distinguish between starvation and deadlock are given below.</p>
<div class="table_wrapper">
<div class="table_wrapper" style="overflow-x:auto;"><table class="alt">
<tbody>
<tr>
<th style="text-align: center;">Features</th>
<th style="text-align: center;">Deadlock</th>
<th style="text-align: center;">Starvation</th>
</tr>
<tr>
<td style="text-align: center;"><strong>Definition</strong></td>
<td style="text-align: center;">Deadlock happens when every process holds a resource and waits for another process to hold another resource.</td>
<td style="text-align: center;">Starvation happens when a low priority program requests a system resource but cannot run because a higher priority program has been employing that resource for a long time.</td>
</tr>
<tr>
<td style="text-align: center;"><strong>Basic</strong></td>
<td style="text-align: center;">A deadlock occurs when no process can proceed and becomes blocked.</td>
<td style="text-align: center;">Starvation occurs when low priority procedures are blocked while high priority operations proceed.</td>
</tr>
<tr>
<td style="text-align: center;"><strong>Other names</strong></td>
<td style="text-align: center;">Deadlock is also known as circular wait.</td>
<td style="text-align: center;">Starvation is known as a Lived lock.</td>
</tr>
<tr>
<td style="text-align: center;"><strong>Resources</strong></td>
<td style="text-align: center;">Other processes block requested resources while a process is deadlocked.</td>
<td style="text-align: center;">High-priority processes continue to use the requested resources.</td>
</tr>
<tr>
<td style="text-align: center;"><strong>Arising Condition</strong></td>
<td style="text-align: center;">Mutual exclusion’s occurrence, Hold and wait, No preemption, and Circular wait all happen simultaneously.</td>
<td style="text-align: center;">Uncontrolled resource management, enforcement of priorities.</td>
</tr>
<tr>
<td style="text-align: center;"><strong>Prevention</strong></td>
<td style="text-align: center;">It can be prevented by avoiding the situations that lead to deadlock.</td>
<td style="text-align: center;">Aging may prevent it.</td>
</tr>
</tbody>
</table></div>
</div>
<p>Deadlock happens when every process holds a resource and waits for another process to hold another resource. Necessary condition for deadlock are:</p>
<ul style="list-style-type: square;">
<li><em><span style="text-decoration: underline;">Mutual Exclusion</span></em> :  Mutual exclusion mean to make two or moreresources unshareable which mean only one process can use the resources at a time.</li>
<li><span style="text-decoration: underline;"><em>Hold and Wait</em></span> : Hold and wait condition simply means that the process must be holding access to one resourse and keep waiting to get access of other resourse for infinite time.</li>
<li><span style="text-decoration: underline;"><em>No Preemption</em></span> : A resource can&#8217;t be preempted from the process and be given to  other process. If there is preemption then there will be no deadlock.</li>
<li><span style="text-decoration: underline;"><em>Circular wait</em></span> : Set of process wait for each other in a circular way or circular form.</li>
</ul>
<p>A <strong>Translation look aside buffer</strong> can be defined as a memory cache which can be used to reduce the time taken to access the page table again and again. It is a memory cache which is closer to the CPU and the time taken by CPU to access TLB is lesser then that taken to access main memory.TLB follows the concept of locality of reference which means that it contains only the entries of those many pages that are frequently accessed by the CPU.</p>
<p>In translation look aside buffers, there are tags and keys with the help of which, the mapping is done. TLB hit is a condition where the desired entry is found in translation look aside buffer. If this happens then the CPU simply access the actual location in the main memory. However, if the entry is not found in TLB (TLB miss) then CPU has to access page table in the main memory and then access the actual frame in the main memory. Therefore, in the case of TLB hit, the effective access time will be lesser as compare to the case of TLB miss. If the probability of TLB hit is P% (TLB hit rate) then the probability of TLB miss (TLB miss rate) will be (1-P) %. Therefore, the effective access time can be defined as;</p>
<div class="codeblock">
<div class="dp-highlighter">
<div class="bar">
<div class="tools">    EAT = P (t + m) + (<span class="number">1</span> – p) (t + k.m + m)</div>
</div>
</div>
</div>
<p>Where, p → TLB hit rate, t → time taken to access TLB, m → time taken to access main memory k = 1, if the single level paging has been implemented.</p>
<p>By the formula, we come to know that</p>
<ol class="points">
<li>Effective access time will be decreased if the TLB hit rate is increased.</li>
<li>Effective access time will be increased in the case of multilevel paging.</li>
</ol>
</div>
<h3>Question 3</h3>
<div><p><p>Why do we need to schedule process? Find the average waiting time and average turnaround time for the following set of processes using FCFS, SJF, RR (Quantum = 3) and shortest remaining time next.</p>
<div class="table_wrapper"><table>
<tbody>
<tr>
<td>Process</td>
<td>CPU brust time</td>
<td>Arrival time</td>
</tr>
<tr>
<td>P1</td>
<td>20</td>
<td>0</td>
</tr>
<tr>
<td>P2</td>
<td>25</td>
<td>15</td>
</tr>
<tr>
<td>P3</td>
<td>10</td>
<td>30</td>
</tr>
<tr>
<td>P4</td>
<td>15</td>
<td>45</td>
</tr>
</tbody>
</table></div</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p>Scheduling a process mean to decide when to preempt one process with another, and which process to start. It is the way to decide which process enters the processor for processing depending on some algorithms. Scheduling is important due to some reasons like:</p>
<ul style="list-style-type: square;">
<li>To minimize resource starvation i.e due to scheduling all the resources and processes gets equal chance to participate in the processing work.</li>
<li>It ensure fairness amongst the parties utilizing the resources.</li>
<li>Due to scheduling, waiting time of the process for the resources are reduced.</li>
<li>Scheduling increase throughput, response and turnaround times and help in wise utilization of CPU resources.</li>
</ul>
<p><strong>Numerical part:</strong></p>
<p>For FCFS(First Come First Served) gantt chart will be as follow:</p>
<p><img data-recalc-dims="1" loading="lazy" decoding="async" class="alignnone size-full wp-image-36526 aligncenter" src="https://i0.wp.com/hamrocsit.com/wp-content/uploads/2024/05/FIFO.drawio-1.png?resize=301%2C66&#038;ssl=1" alt="" width="301" height="66"></p>
<div class="table_wrapper" style="overflow-x:auto;"><table style="border-collapse: collapse; width: 100%;">
<tbody>
<tr>
<td style="width: 11.204%; text-align: center;"><strong>Process</strong></td>
<td style="width: 44.9833%; text-align: center;"><strong>Turnaround Time</strong></p>
<p><strong>(Completion Time – Arrival Time)</strong></td>
<td style="width: 43.8127%; text-align: center;"><strong>Waiting Time</strong></p>
<p><strong>(Turnaround Time – Burst Time)</strong></td>
</tr>
<tr>
<td style="width: 11.204%; text-align: center;">P1</td>
<td style="width: 44.9833%; text-align: center;">20-0=20</td>
<td style="width: 43.8127%; text-align: center;">20-20=0</td>
</tr>
<tr>
<td style="width: 11.204%; text-align: center;">P2</td>
<td style="width: 44.9833%; text-align: center;">45-15=30</td>
<td style="width: 43.8127%; text-align: center;">30-25=5</td>
</tr>
<tr>
<td style="width: 11.204%; text-align: center;">P3</td>
<td style="width: 44.9833%; text-align: center;">55-30=25</td>
<td style="width: 43.8127%; text-align: center;">25-10=15</td>
</tr>
<tr>
<td style="width: 11.204%; text-align: center;">P4</td>
<td style="width: 44.9833%; text-align: center;">70-45=25</td>
<td style="width: 43.8127%; text-align: center;">25-15=10</td>
</tr>
</tbody>
</table></div>
<p>$$ Average TAT = \frac{{20+30+25+25}}{{4}}$$</p>
<p>$$  = 25$$</p>
<p>$$ Average WT = \frac{{0+5+15+10}}{{4}}$$</p>
<p>$$  = 7.5$$</p>
<p>&nbsp;</p>
<p>For SJF(Shortest Job First) gantt chart will be as follow:</p>
<p><img data-recalc-dims="1" loading="lazy" decoding="async" class="alignnone size-full wp-image-36526 aligncenter" src="https://i0.wp.com/hamrocsit.com/wp-content/uploads/2024/05/FIFO.drawio-1.png?resize=301%2C66&#038;ssl=1" alt="" width="301" height="66"></p>
<div class="table_wrapper" style="overflow-x:auto;"><table style="border-collapse: collapse; width: 100%;">
<tbody>
<tr>
<td style="width: 11.204%; text-align: center;"><strong>Process</strong></td>
<td style="width: 44.9833%; text-align: center;"><strong>Turnaround Time</strong></p>
<p><strong>(Completion Time – Arrival Time)</strong></td>
<td style="width: 43.8127%; text-align: center;"><strong>Waiting Time</strong></p>
<p><strong>(Turnaround Time – Burst Time)</strong></td>
</tr>
<tr>
<td style="width: 11.204%; text-align: center;">P1</td>
<td style="width: 44.9833%; text-align: center;">20-0=20</td>
<td style="width: 43.8127%; text-align: center;">20-20=0</td>
</tr>
<tr>
<td style="width: 11.204%; text-align: center;">P2</td>
<td style="width: 44.9833%; text-align: center;">45-15=30</td>
<td style="width: 43.8127%; text-align: center;">30-25=5</td>
</tr>
<tr>
<td style="width: 11.204%; text-align: center;">P3</td>
<td style="width: 44.9833%; text-align: center;">55-30=25</td>
<td style="width: 43.8127%; text-align: center;">25-10=15</td>
</tr>
<tr>
<td style="width: 11.204%; text-align: center;">P4</td>
<td style="width: 44.9833%; text-align: center;">70-45=25</td>
<td style="width: 43.8127%; text-align: center;">25-15=10</td>
</tr>
</tbody>
</table></div>
<p>$$ Average TAT = \frac{{20+30+25+25}}{{4}}$$</p>
<p>$$  = 25$$</p>
<p>$$ Average WT = \frac{{0+5+15+10}}{{4}}$$</p>
<p>$$  = 7.5$$</p>
</div>
<h2>SECTION B: Attempt any EIGHT question</h2><h3>Question 4</h3>
<div><p><p>What is system call ? Describe the transition between different states of process.</p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p>The interface between a process and an operating system is provided by <strong>system calls</strong>. In general, system calls are available as assembly language instructions. They are also included in the manuals sed by the assembly level programmers. System calls are usually made when a process in user mode requires access to a resource. Then it requests the kernal to provide the resource via a system call. A figure representing the execution of the system call is given as follows:</p>
<p style="text-align: center;"><img data-recalc-dims="1" loading="lazy" decoding="async" class="alignnone  wp-image-36361" src="https://i0.wp.com/hamrocsit.com/wp-content/uploads/2024/05/system-call.drawio.png?resize=505%2C308&#038;ssl=1" alt="" width="505" height="308"></p>
<p>&nbsp;</p>
<p>A process is an independent entity with its own input values, output values and internal state. A process output can be considered as input of other process. Every process goes through different states. The transition between different states of process can be shown in figure below:</p>
<p style="text-align: center;"><img data-recalc-dims="1" loading="lazy" decoding="async" class="alignnone  wp-image-36362" src="https://i0.wp.com/hamrocsit.com/wp-content/uploads/2024/05/states.drawio.png?resize=480%2C183&#038;ssl=1" alt="" width="480" height="183"></p>
<ul style="list-style-type: square;">
<li><strong><em>New</em></strong> : It is the phases where the process is being created.</li>
<li><em><strong>Ready</strong></em> : It is the state where the process waits for being assigned to any processor.</li>
<li><em><strong>Running</strong></em> : It is the state where the process is being executed by the processor.</li>
<li><em><strong>Waiting</strong></em> : It is the phase where the process which need some i/o service needs to wait or those process waits here which have some issue being assigned to any processor at that instance.</li>
<li><em><strong>Terminate</strong></em> : Those process reaches here which has been sucessfully executed.</li>
</ul>
</div>
<h3>Question 5</h3>
<div><p><p>Discuss about contiguous and linked list file allocation technique.</p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p><strong>Contiguous Technique</strong></p>
<p>In a contiguous allocation, each file occupies a single, contiguous block of storage space on the storage medium. Files are stored in a continuous sequence of blocks. Contiguous allocation is not very flexible in terms of file size. You need to allocate a fixed size of contiguous space for a file when it is created. This can lead to inefficient space utilization if the file size varies significantly. Contiguous allocation can lead to external fragmentation. When files are created, deleted, and resized over time, small gaps or holes of unused space can develop between allocated blocks, reducing storage efficiency.</p>
<p style="text-align: center;"><img data-recalc-dims="1" loading="lazy" decoding="async" class="alignnone size-full wp-image-36376" src="https://i0.wp.com/hamrocsit.com/wp-content/uploads/2024/05/contieous.drawio.png?resize=205%2C295&#038;ssl=1" alt="" width="205" height="295"></p>
<p>Accessing files in contiguous allocation is usually faster because the entire file is stored in a contiguous block. File access time is predictable, and there is no need to traverse data structures to find the next block of a file. Periodic defragmentation may be required to consolidate free space and reduce fragmentation, but this can be a time-consuming process.</p>
<p><strong>Linked list Technique</strong></p>
<p>In linked list allocation, each file is divided into blocks or segments, and these blocks are linked together using pointers. Each block contains data and a pointer to the next block in the file. Linked list allocation allows for more flexibility in file size. Files can grow or shrink dynamically by adding or removing blocks from the linked list. Linked list allocation does not suffer from external fragmentation. Files are stored in non-contiguous blocks, and unused space is easily reclaimed when a file is deleted or resized.</p>
<p style="text-align: center;"><img data-recalc-dims="1" loading="lazy" decoding="async" class="alignnone size-full wp-image-36375" src="https://i0.wp.com/hamrocsit.com/wp-content/uploads/2024/05/linkedlist.drawio.png?resize=205%2C295&#038;ssl=1" alt="" width="205" height="295"></p>
<p>Accessing files in linked list allocation can be slower because the system needs to follow pointers to traverse the linked blocks. However, it is more adaptable to varying file sizes and avoids the need for contiguous free space. There is no need for defragmentation in linked list allocation because fragmentation is not an issue.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
</div>
<h3>Question 6</h3>
<div><p><p>Why do we need virtual memory? Describe the sructure of a page table.</p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p>Virtual memory is a technique of executing programs/ instruction that may not fit entirely in the system memory. It has some benefits as:</p>
<ul style="list-style-type: square;">
<li>It can handle twice as many addresses that a main memory actually have or can i.e more processes may be maintained in the main memory.</li>
<li>It increases security because of memory isolation.</li>
<li value="9">It makes it possible for several larger applications to run at once.</li>
<li value="11">It doesn’t require outside fragmentation.</li>
<li value="13">Automatic data movement is possible.</li>
</ul>
<p>As we get these benefits from virtual memory so we prefer or need virtual memory.</p>
<p>A page table is the data structure , used by virtual memory system in computer operating system to store the mapping between virtual adresses and physical addresses.</p>
<p style="text-align: center;"><img data-recalc-dims="1" loading="lazy" decoding="async" class="alignnone size-full wp-image-36420" src="https://i0.wp.com/hamrocsit.com/wp-content/uploads/2024/05/pagetable.drawio.png?resize=734%2C62&#038;ssl=1" alt="" width="734" height="62"></p>
<p>A page table contains following in the page table structure:</p>
<ol style="list-style-type: lower-alpha;">
<li>Frame number : Frame number stores the value or the number of the frame at which the particular data is stored in the page table.  It gives the frame number in which the current page you are looking for is present. The number of bits required depends on the number of frames. Frame bit is also known as address translation bit.</li>
<li>Present / Absent : Present or absent bit says whether a particular page you are looking for is present or absent.</li>
<li>Protection :  The protection bit says what kind of protection you want on that <span tabindex="0" role="tooltip"><span class="c5aZPb" tabindex="0" role="button" data-enable-toggle-animation="true" data-extra-container-classes="ZLo7Eb" data-hover-hide-delay="1000" data-hover-open-delay="500" data-send-open-event="true" data-theme="0" data-width="250" data-ved="2ahUKEwiy3cWC756GAxUg1TgGHQT_A6gQmpgGegQIIhAD"><span class="JPfdse" data-bubble-link="" data-segment-text="page">page</span></span></span>. So, these bits are for the protection of the page frame (read, write, etc).</li>
<li>Othe bits : It contain bits as Referenced Bit, Caching Enabled/Disabled, Modified Bit. they all have their own functioning. Referenced bit will say whether this page has been referred to in the last clock cycle or not. Modified bit says whether the page has been modified or not.</li>
</ol>
</div>
<h3>Question 7</h3>
<div><p><p>Illustrate the term safe and unsafe state in deadlock prevention with scenario.</p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p><strong>Safe State</strong>:</p>
<p>A system is considered to be in a safe state if it can allocate resources to each process in some order and still avoid a deadlock. Formally, a safe state exists if there exists a sequence of processes where each process can complete its execution and release its resources without causing a deadlock.</p>
<p><strong>Example</strong>: Imagine a system with three processes P1, P2, and P3 and three resource types R1, R2, and R3. If the available resources allow the following allocation: P1 → R1, P2 → R2, P3 → R3, then the system is in a safe state.</p>
<p>&nbsp;</p>
<p><strong>Unsafe State</strong>:</p>
<p>A system is in an unsafe state if all of the resource requirements of a process cannot be met by the available resources in any way. In an unsafe state, the system cannot prevent processes from requesting resources in such a way that a deadlock occurs.</p>
<p><strong>Example</strong>: Suppose we have the same system as above, but the available resources are allocated as follows: P1 → R1, P2 → R2. Now, if P3 requests R3, the system becomes unsafe because there’s no way to satisfy P3’s request without risking a deadlock.</p>
</div>
<h3>Question 8</h3>
<div><p><p>How lock variable is used in achieving mutual exclusion? Describe.</p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p>Lock variable is a software mechanism which is only for user mode or we say it is free from OS mode or kernel mode. It is a solution for busy waiting. Here, more tha two process can enter the critical section at same time. It uses the mutual exclusion to solve the lock variable problem.<span style="font-size: 12pt;"><br />
</span></p>
<p><img data-recalc-dims="1" loading="lazy" decoding="async" class="alignnone  wp-image-36480 aligncenter" src="https://i0.wp.com/hamrocsit.com/wp-content/uploads/2024/05/Lock-Variable.drawio.png?resize=255%2C270&#038;ssl=1" alt="" width="255" height="270"></p>
<p>Initially, the lock is set to 0. In entry section, the while statement is checked by the process 1. If the lock is 0, then the while statement is false and it enters the entry section and set the lock to 1 then execute critical section. When the other process i.e process 2 tries to enter the loop the condition is checked but due to lock 1 it couldn&#8217;t enter the and get stuck in the loop.</p>
<p>Until the process 1 executes the critical section and set the lock 0 the other process i.e process 2 can&#8217;t enter. This goes on and the lock is switched between processes one by one. Hence, in this way by the help of lock variable mutual exclusion is achieved.</p>
</div>
<h3>Question 9</h3>
<div><p><p>Why do we need hierarchical directory system? Explain structure of disk.</p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p><strong>Hierarchical directory system</strong> is a method to create files and subdirectories for making the access of file easy and fast. Here directories except than the root directory can be accessed by user and user can create and store files in them. Root directory is at the peak and contains all the directories for each user but user are not allowed to access them or modify them.</p>
<ul style="list-style-type: square;">
<li value="1">This structure allows multiple subdirectories inside a directory and so on.</li>
<li value="2">Due to tree like structre accessinf is more faster.</li>
<li value="3">Important and unimportant files can be sorted easily.</li>
<li value="4">This directory is more scalable than the other two directory structures explained.</li>
</ul>
<div style="text-align: center;"><img data-recalc-dims="1" loading="lazy" decoding="async" class="alignnone  wp-image-36470" src="https://i0.wp.com/hamrocsit.com/wp-content/uploads/2024/05/diskStructure.drawio.png?resize=411%2C218&#038;ssl=1" alt="" width="411" height="218"></div>
<p>The disk is divided into number of tracks and each tracks are divided into sectors. A hard disk uses round, flat disks called platters, coated on both sides with a special media material designed to store information in the form of magnetic patterns.</p>
<ul style="list-style-type: square;">
<li><strong>Platters</strong> : Platters are flat, circular organized cocentric stack. They are place one upon other.</li>
<li><strong>Surface</strong> : Surface are the sides of platter. A platter contain two sides so we can say that each platter contain two surfaces.</li>
<li><strong>Tracks</strong> : Tracks are the circular path on the surfaces of the platter. There are multiple tracks on a surface.</li>
<li><strong>Sector</strong> : Sectors are the division of the track where the data can be stored. Every track has a number of sector.</li>
<li><strong>Read/Write Head</strong> : Read/Write head are placed on the track of the platter. They move from one sector to other and point out the sector where the data are to be written or from where the data are to be read.</li>
</ul>
</div>
<h3>Question 10</h3>
<div><p><p>Find the number of page fault using FIFO and LRU for the refrence string  4, 7, 6, 1, 7, 6, 1, 2, 7, 2 with frame size 3.</p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p>To calculate the page faults using OPR and FIFO page replacement algorithms, we first need to understand how these algorithms work.</p>
<p>FIFO (First-In-First-Out) algorithm replaces the page that has been in the memory for the longest time. It’s a simple algorithm that keeps track of the order in which pages were loaded into the memory and replaces the oldest page first.</p>
<p>given,</p>
<p>Memory refrences = 4, 7, 6, 1, 7, 6, 1, 2, 7, 2</p>
<p>and frame size = 3</p>
<p style="text-align: center;"><img data-recalc-dims="1" loading="lazy" decoding="async" class="alignnone size-full wp-image-36416" src="https://i0.wp.com/hamrocsit.com/wp-content/uploads/2024/05/FIFO1.drawio.png?resize=601%2C201&#038;ssl=1" alt="" width="601" height="201"></p>
<p>Number of page fault = 6</p>
<p>Number of page Hit = 4</p>
<p>LRU (Least-Recently-Used) algorithm replaces the page that has not been in use for the longest time in memory . It’s an algorithm that keeps track of the order in which pages were loaded into the memory and replaces the  page first which has not been used recently.</p>
<p>given,</p>
<p>Memory refrences = 4, 7, 6, 1, 7, 6, 1, 2, 7, 2</p>
<p>and frame size = 3</p>
<p style="text-align: center;"><img data-recalc-dims="1" loading="lazy" decoding="async" class="alignnone size-full wp-image-36416" src="https://i0.wp.com/hamrocsit.com/wp-content/uploads/2024/05/FIFO1.drawio.png?resize=601%2C201&#038;ssl=1" alt="" width="601" height="201"></p>
<p>Number of page fault = 6</p>
<p>Number of page Hit = 4</p>
<p>We see that for the given refrences FIFO and LRU give same number of page hit and page fault.</p>
</div>
<h3>Question 11</h3>
<div><p><p>Define working set. How does clock replacement algorithm works?</p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p>The <em><strong>working set</strong></em> of a process is the set of pages in the virtual address space of the process that are currently resident in physical memory. It is a concept in computer science which defines the amount of memory that a process requires in a given time interval. It refers to the amount of physical memory (RAM) the process uses.</p>
<p>A <em><strong>clock page replacement algorithm </strong></em>keeps a circular list of pages in memory, with the &#8220;hand&#8221; pointing the last examined page frame in the list. When a page faults occour and no empty frame exist then the R (refrence) bit is insppected at hand location. If R is 0 the the new page is placed in the place of the page the hand points to, and the hand is advanced one position. Otherwise, the R bit is cleared, then the clock hand is incremented and the process is repeated until a page is replaced.</p>
<p>For eg : If input refrences are 1, 2, 3, 4, 3, 1, 2, 1, 5, 4 and frame is 3 then show it by page replacement method.</p>
<p><img data-recalc-dims="1" loading="lazy" decoding="async" class="alignnone size-full wp-image-36432" src="https://i0.wp.com/hamrocsit.com/wp-content/uploads/2024/05/clock-replacement.drawio.png?resize=1155%2C788&#038;ssl=1" alt="" width="1155" height="788"></p>
<p>Total number of page fault = 8</p>
<p>Total number of page Hit = 2</p>
</div>
<h3>Question 12</h3>
<div><p><p>Write short notes on :</p>
<ol>
<li>Inode</li>
<li>RAID</li>
</ol</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><blockquote><p>a.<strong><span style="text-decoration: underline;"> Inode</span> :</strong></p></blockquote>
<p>An inode (index node) is a data structure used in a Unix-style file system to store information about a file or a directory. Each file or directory on the file system is associated with an inode, which contains metadata such as file size, ownership, permissions, timestamps, and pointers to the actual data blocks on the disk. It is superior to other file allocation approaches because:</p>
<ol style="list-style-type:decimal;">
<li><em><span style="text-decoration: underline;">Efficient Metadata Storage:</span></em> Inodes store all the metadata related to a file compactly and efficiently.</li>
<li><span style="text-decoration: underline;"><em>Efficient File Access:</em></span> Direct pointers in inodes allow for quick access to data blocks, reducing access time.</li>
<li><span style="text-decoration: underline;"><em>Support for Variable-Sized Files:</em></span> Inodes can support variable-sized files by using direct, indirect, double-indirect, and triple-indirect pointers.</li>
</ol>
<p>&nbsp;</p>
<blockquote><p>b. <span style="text-decoration: underline;"><strong>RAID</strong></span> :</p></blockquote>
<p>RAID stands for Redundant Array of Independent Disk. It is a technique which use a combination of multiple disks instead of using a single disk for increased performance, data redundancy or both. It ia the way of storing the same data in different places on multiple hard disk to protect data in the case of driver failuer. It works by placing data on multiple disk and allowing I/O operations to overlap in a balanced way, improving performance.</p>
<ul style="list-style-type: square;">
<li><span style="text-decoration: underline;"><em>Stripping in RAID</em></span> :  The process of dividing large data into multiple disks for faster access is called stripping in RAID.</li>
<li><span style="text-decoration: underline;"><em>Mirrioring in RAID</em></span> : It is a mechanism in which the same data is written to another disk driver.</li>
<li><span style="text-decoration: underline;"><em>Parity in RAID</em> </span>: It is a method used to rebuild data in case of failuer of one of the disks.</li>
<li><span style="text-decoration: underline;"><em>Hot spares in RAID</em></span> : Hot spares is an extra driver added to the disk array, to increase the fault tolerance.</li>
</ul>
<p>&nbsp;</p>
</div>
</body></html>