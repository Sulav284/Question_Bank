
    <html>
    <head>
        <meta charset="UTF-8">
        <title>MP Question Bank 2079 2079</title>
    </head>
    <body>
        <h1>MP Question Bank 2079 - 2079</h1>
        <p><strong>Full Marks:</strong> 60 + 20 + 20</p>
        <p><strong>Pass Marks:</strong> 24 + 8 + 8</p>
        <p><strong>Time:</strong> 3 hours</p>
    <h2>Group A: Attempts any TWO questions (2 x 10 = 20):</h2><h3>Question 1</h3>
<div><p><p>What is instruction cycle? Draw timing diagram of MOV A, B. Make necessary assumptions.</p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p>An instruction cycle is a basic operation performed by a computer&#8217;s CPU (central processing unit) to execute a single instruction. It is a sequence of steps that the CPU goes through to fetch, decode, and execute an instruction from memory. The instruction cycle is repeated for each instruction that needs to be executed.</p>
<p>The instruction cycle typically consists of the following steps:</p>
<ol style="list-style-type:decimal;">
<li><strong>Fetch:</strong> The CPU fetches the next instruction from memory and stores it in its instruction register.</li>
<li><strong>Decode:</strong> The CPU decodes the instruction, determining the operation to be performed and the operands involved.</li>
<li><strong>Execute:</strong> The CPU performs the operation specified by the instruction on the operands.</li>
</ol>
<p><span style="text-decoration: underline;"><strong>Timing Diagram MOV A, B:</strong></span></p>
<p>The time taken by the processor to execute the Opcode Fetch cycle is 4T (T- states). The first 3 T-states are used for fetching the Opcode from memory and the remaining T-state is used for internal operations by the microprocessor. The timing diagram for MOV A, B (Opcode Fetch machine cycle) is shown in the figure. It has 4 T states.</p>
<p><img loading="lazy" decoding="async" class="size-full wp-image-12774 aligncenter" src="https://hamrocsit.com/wp-content/uploads/2022/06/Capture.jpg" alt="" width="656" height="495"></p>
<p style="font-weight: 400;">The steps for the machine cycle of MOV Rd, Rs instruction are given in the table.</p>
<div class="table_wrapper" style="overflow-x:auto;"><table class="table">
<tbody>
<tr>
<td><b><strong>S.No</strong></b></td>
<td><b><strong>T state</strong></b></td>
<td><b><strong>Operation</strong></b></td>
</tr>
<tr>
<td>1</td>
<td rowspan="3">T1</td>
<td>The microprocessor places the higher order 8 bits of the Program Counter on the A15 – A8 address bus and the lower order 8 bits of the Program Counter on the AD7 – AD0 address/data bus.</td>
</tr>
<tr>
<td>2</td>
<td>The microprocessor makes the ALE signal HIGH and in the middle of the T1 state, the ALE signal goes LOW.</td>
</tr>
<tr>
<td>3</td>
<td>The status signals are changed as IO/M&#8217;= 0, S1 =1, and S0 = 1. These status signals do not change throughout the OF machine cycle.</td>
</tr>
<tr>
<td>4</td>
<td rowspan="2">T2</td>
<td>The microprocessor makes the RD&#8217;s line LOW to enable memory reading (opcode fetch) and increments the Program Counter.</td>
</tr>
<tr>
<td>5</td>
<td>The contents on D7 – D0 (i.e. the Opcode) are placed on the address/data bus.</td>
</tr>
<tr>
<td>6</td>
<td rowspan="2">T3</td>
<td>The microprocessor transfers the Opcode on the address/data bus to Instruction Register (IR).</td>
</tr>
<tr>
<td>7</td>
<td>The microprocessor decodes the instruction.</td>
</tr>
<tr>
<td>8</td>
<td>T4</td>
<td>The data in register B is moved to register A.</td>
</tr>
</tbody>
</table></div>
</div>
<h3>Question 2</h3>
<div><p><p>Explain the architecture of of 80386 with required figure. Highlight on its register organization.</p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p>The figure below shows the architectural representation of the 80386 microprocessor:</p>
<p><img loading="lazy" decoding="async" class="aligncenter wp-image-1521 size-full" src="https://electronicsdesk.com/wp-content/uploads/2019/06/architecture-of-80386-microprocessor.jpg" sizes="auto, (max-width: 600px) 100vw, 600px" srcset="https://electronicsdesk.com/wp-content/uploads/2019/06/architecture-of-80386-microprocessor.jpg 600w, https://electronicsdesk.com/wp-content/uploads/2019/06/architecture-of-80386-microprocessor-300x180.jpg 300w" alt="architecture of 80386 microprocessor" width="600" height="360" />Basically, it has 6 functional units which are as follows:</p>
<ol style="list-style-type:decimal;">
<li>Bus Interface Unit</li>
<li>Code Fetch Unit</li>
<li>Instruction Decode Unit</li>
<li>Execution Unit</li>
<li>Memory Management Unit</li>
</ol>
<p>As we have already discussed that the 80386 possesses the ability of 3 stages of pipelining thus performing fetching, decoding, and execution simultaneously along with memory management and bus accessing. Thus all these units operate parallelly. This pipelining technique leads to a reduction in overall processing time thereby increasing the performance of the overall system.</p>
<p>Let us now move further and understand the operation of each unit in detail.</p>
<p><span style="text-decoration: underline;"><strong>1. Bus Interface Unit:</strong></span></p>
<p>The bus interface unit or BIU holds a 32-bit bidirectional data bus as well as a 32-bit address bus. Whenever a need for instruction or a data fetch is generated by the system then the BIU generates signals (according to the priority) for activating the data and address bus in order to fetch the data from the desired address.</p>
<p>The BIU connects the peripheral devices through the memory unit and also controls the interfacing of external buses with the coprocessors.</p>
<p><span style="text-decoration: underline;"><strong>2. Code Prefetch Unit:</strong></span></p>
<p>This unit fetches the instructions stored in the memory by making use of system buses. Whenever the system generates a need for instruction then the code prefetch unit fetches that instruction from the memory and stores it in a 16-byte prefetch queue. So to speed up the operation this unit fetches the instructions in advance and the queue stores these instructions. The sequence in which the instructions are fetched and gets stored in the queue depends on the order they exist in the memory.<br />
As this unit fetches one double word in a single access. So, in such a case, it is not necessary that each time only a single instruction will be fetched, as the fetched instruction can be parts of two different instructions.</p>
<p>It is to be noted here that, code prefetching holds lower priority than data transferring. As whenever a need for data transfer is generated by the system then immediately the code prefetcher leaves control over the buses. So that the BIU can transfer the required data. But prefetching of instruction and storing it in the queue reduces the wait for the upcoming instruction to almost zero.</p>
<p><span style="text-decoration: underline;"><strong>3. Instruction Decode Unit:</strong></span></p>
<p>We know that instructions in the memory are stored in the form of bits. So, this unit decodes the instructions stored in the prefetch queue. Basically, the decoder changes the machine language code into assembly language and transfers it to the processor for further execution.</p>
<p><span style="text-decoration: underline;"><strong>4. Execution Unit:</strong></span></p>
<p>The decoded instructions are stored in the decoded instruction queue. So, these instructions are provided to the execution unit in order to execute the instructions. The execution unit controls the execution of the decoded instructions. This unit has a 32-bit ALU, that performs the operation over 32-bit data in one cycle. Also, it consists of 8 general purpose as well as 8 special purpose registers. These are used for data handling and calculation of offset addresses.</p>
<p><span style="text-decoration: underline;"><strong>5. Memory Management Unit:</strong></span></p>
<p>This unit has two separate units within it. These are</p>
<ol style="list-style-type:decimal;">
<li>Segmentation Unit and</li>
<li>Paging Unit</li>
</ol>
<p><strong>Segmentation unit</strong>: The segmentation unit plays a vital role in the 80836 microprocessor. It offers a protection mechanism in order to protect the code or data present in the memory from application programs. It gives 4-level protection to the data or code present in the memory. Every piece of information in the memory is assigned a privilege level from PL0 to PL3. Here, <em><strong>PL0 holds the highest priority</strong></em> and PL3 holds the lowest priority.</p>
<p><strong>Paging Unit</strong>: The paging unit operates only in protected mode and it changes the linear address into a physical address. As the programmer only provides the virtual address and not the physical address. The segmentation unit controls the action of the paging unit, as the segmentation unit has the ability to convert the logical address into the linear address at the time of executing an instruction. Basically, it changes the overall task map into pages and each page has a size of <strong>4K</strong>. This allows the handling of tasks in the form of pages rather than segments.</p>
</div>
<h3>Question 3</h3>
<div><p><p>Write an assembly language program to find the largest number of an array using 8 bit microprocessor. (Assume appropriate array data and address where minimum array size of 15 should be considered)</p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p>LDA 3000H   ; Load first element of the array into the accumulator</p>
<p>MOV C, A    ; Move the contents of the accumulator to register C</p>
<p>MOV B, 01H   ; Initialize counter B with 1</p>
<p>&nbsp;</p>
<p>Loop:</p>
<p>LDA 3000H, B  ; Load next element of the array into the accumulator</p>
<p>INR B     ; Increment counter B</p>
<p>CPI C, A    ; Compare the contents of accumulator and register C</p>
<p>JM L1     ; If accumulator &gt; C, jump to label L1</p>
<p>MOV C, A    ; Otherwise, move the contents of the accumulator to register C</p>
<p>&nbsp;</p>
<p>JMP Loop    ; Repeat loop until all elements have been processed</p>
<p>&nbsp;</p>
<p>L1: NOP     ; Label L1 (do nothing)</p>
<p>HLT      ; Halt the program</p>
</div>
<h2>Group B: Attempts any EIGHT questions (8 x 5 = 40):</h2><h3>Question 4</h3>
<div><p><p>Write an assembly language program for 8086 to read two strings and check whether they are same or not.</p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p>Here is an assembly language program for the 8086 processor to read two strings and check whether they are the same or not:</p>
<pre class="EnlighterJSRAW" data-enlighter-language="generic">; Program to read two strings and check if they are the same
; Written for 8086 processor

    .model small
    .stack 100h

    ; Define data segment
    .data
    message1 db "Enter first string: $"
    message2 db "Enter second string: $"
    matchMsg db "Strings match!$"
    noMatchMsg db "Strings do not match!$"
    string1 db 20,?,dup('$') ; first string with maximum length of 20
    string2 db 20,?,dup('$') ; second string with maximum length of 20
    strLength dw ?

    ; Define code segment
    .code
    main proc
        ; Initialize data segment
        mov ax, @data
        mov ds, ax

        ; Read first string
        mov ah, 09h
        lea dx, message1
        int 21h
        mov ah, 0ah
        lea dx, string1
        int 21h

        ; Read second string
        mov ah, 09h
        lea dx, message2
        int 21h
        mov ah, 0ah
        lea dx, string2
        int 21h

        ; Compare strings
        lea si, string1+2
        lea di, string2+2
        mov cx, [string1] ; get length of first string
        cmp cx, [string2] ; compare to length of second string
        jne noMatch ; if not equal, strings do not match
        repe cmpsb ; compare each character until end of strings or mismatch
        je match ; if equal, strings match

    noMatch:
        ; Output message for non-matching strings
        mov ah, 09h
        lea dx, noMatchMsg
        int 21h
        jmp exit

    match:
        ; Output message for matching strings
        mov ah, 09h
        lea dx, matchMsg
        int 21h

    exit:
        ; Exit program
        mov ah, 4ch
        int 21h

    main endp
    end main</pre>
<p>This program reads two strings from the user and compares them character by character using the <code>cmpsb</code> instruction. If any character mismatches or the length of the strings is not the same, the program outputs a message indicating that the strings do not match. If all characters match, the program outputs a message indicating that the strings match.</p>
<p>Note that the specific instructions used in this program may vary depending on the assembly language syntax and programming conventions used.</p>
</div>
<h3>Question 5</h3>
<div><p><p>Explain different types of instruction group of 8085.</p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p>The instruction set of the 8085 microprocessor can be broadly classified into the following groups:</p>
<ol style="list-style-type:decimal;">
<li>Data Transfer Instructions: These instructions are used to transfer data from one register to another, from memory to register, or vice versa.</li>
<li>Arithmetic Instructions: These instructions are used to perform arithmetic operations such as addition, subtraction, increment, decrement, etc.</li>
<li>Logical Instructions: These instructions are used to perform logical operations such as AND, OR, XOR, NOT, etc.</li>
<li>Branch Instructions: These instructions are used to transfer the flow of control to a different part of the program based on a condition.</li>
<li>Machine Control Instructions: These instructions are used to control the microprocessor&#8217;s internal operations, such as setting the flag register, enabling or disabling interrupts, etc.</li>
<li>Input/Output Instructions: These instructions are used to communicate with the external devices connected to the microprocessor. Each instruction in the 8085 instruction set has a unique opcode, and the operation performed by the instruction depends on the opcode.</li>
</ol>
</div>
<h3>Question 6</h3>
<div><p><p>Explain different addressing modes of 8086.</p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p>The way of specifying data to be operated by an instruction is known as <b>addressing modes</b>. This specifies that the given data is an immediate data or an address. It also specifies whether the given operand is register or register pair.</p>
<p>Types of addressing modes:</p>
<ol style="list-style-type:decimal;">
<li><strong>Register mode –</strong> In this type of addressing mode both the operands are registers.<br />
Example:</p>
<div id="GFG_AD_gfg_mobile_336x280"></div>
<pre>MOV AX, BX
XOR AX, DX
ADD AL, BL</pre>
</li>
<li><strong>Immediate mode –</strong> In this type of addressing mode the source operand is a 8 bit or 16 bit data. Destination operand can never be immediate data.<br />
Example:</p>
<pre>MOV AX, 2000
MOV CL, 0A
ADD AL, 45
AND AX, 0000</pre>
<p>Note that to initialize the value of segment register an register is required.</p>
<pre>MOV AX, 2000
MOV CS, AX</pre>
</li>
<li><strong>Displacement or direct mode –</strong> In this type of addressing mode the effective address is directly given in the instruction as displacement.<br />
Example:</p>
<pre>MOV AX, [DISP]
MOV AX, [0500]</pre>
</li>
<li><strong>Register indirect mode –</strong> In this addressing mode the effective address is in SI, DI or BX.<br />
Example: Physical Address = Segment Address + Effective Address</p>
<pre>MOV AX, [DI]
ADD AL, [BX]
MOV AX, [SI]</pre>
</li>
<li><strong>Based indexed mode –</strong> In this the effective address is sum of base register and index register.
<pre>Base register: BX, BP
Index register: SI, DI</pre>
<p>The physical memory address is calculated according to the base register.<br />
Example:</p>
<pre>MOV AL, [BP+SI]
MOV AX, [BX+DI]</pre>
</li>
<li><strong>Indexed mode –</strong> In this type of addressing mode the effective address is sum of index register and displacement.<br />
Example:</p>
<pre>MOV AX, [SI+2000]
MOV AL, [DI+3000]</pre>
</li>
<li><strong>Based mode –</strong> In this the effective address is the sum of base register and displacement.<br />
Example:</p>
<pre>MOV AL, [BP+ 0100]</pre>
</li>
<li><strong>Based indexed displacement mode –</strong> In this type of addressing mode the effective address is the sum of index register, base register and displacement.<br />
Example:</p>
<pre>MOV AL, [SI+BP+2000]</pre>
</li>
<li><strong>String mode –</strong> This addressing mode is related to string instructions. In this the value of SI and DI are auto incremented and decremented depending upon the value of directional flag.<br />
Example:</p>
<pre>MOVS B
MOVS W</pre>
</li>
<li><strong>Input/Output mode –</strong> This addressing mode is related with input output operations.<br />
Example:</p>
<pre>IN A, 45
OUT A, 50</pre>
</li>
<li><strong>Relative mode –</strong><br />
In this the effective address is calculated with reference to instruction pointer.<br />
Example:</p>
<pre>JNZ 8 bit address
IP=IP+8 bit address</pre>
</li>
</ol>
<div class="textBasedMannualAds_2"></div>
</div>
<h3>Question 7</h3>
<div><p><p>Explain the concept of multitasking in 80286.</p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p>Multitasking is the ability of an operating system to run multiple tasks or programs concurrently. In the case of the 80286 processor, multitasking is achieved through a mechanism called &#8220;protected mode&#8221;.</p>
<p>In protected mode, the 80286 processor uses virtual memory addressing, allowing multiple programs to be loaded into memory at the same time. Each program is given its own virtual address space, which isolates it from other programs running on the system. The operating system&#8217;s task scheduler then switches between the different programs, giving each one a turn to execute on the processor.</p>
<p>To facilitate this switching between programs, the 80286 processor includes a set of task management features. These features include the Task Register, which keeps track of the currently executing program, and the Task State Segment, which stores information about a program&#8217;s state when it is not currently executing.</p>
<p>Overall, the multitasking capability of the 80286 processor allows multiple programs to run concurrently, improving system efficiency and enabling more complex applications to be developed.</p>
</div>
<h3>Question 8</h3>
<div><p><p>What are the practical implications of asynchronous serial communication? Explain DTE-DCE connection according to RS-232 serial communication standard.</p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p>Asynchronous serial communication is a way of transmitting data between two devices one bit at a time. This type of communication is used in many applications, including computer networks, telecommunications, and industrial automation. Some of the practical implications of asynchronous serial communication are:</p>
<ol style="list-style-type:decimal;">
<li>Low cost: Asynchronous serial communication is simple to implement and requires few hardware components, making it a cost-effective solution for many applications.</li>
<li>High reliability: Asynchronous serial communication uses a start bit, data bits, parity bit, and stop bit to ensure that data is transmitted accurately and reliably.</li>
<li>Versatility: Asynchronous serial communication can be used to transmit both text and binary data, making it suitable for a wide range of applications.</li>
<li>Long-distance communication: Asynchronous serial communication can be used over long distances, as long as the signal quality is good and appropriate signal conditioning is used.</li>
</ol>
<p>In the context of the RS-232 serial communication standard, the connection between the Data Terminal Equipment (DTE) and the Data Communications Equipment (DCE) is an essential aspect of asynchronous serial communication. The DTE is the device that generates or consumes data, while the DCE is the device that provides the communication channel and may perform some signal conversion.</p>
<p>According to the RS-232 standard, the DTE-DCE connection should use a 25-pin connector or a 9-pin connector. The connection uses a transmit data line (TXD), a receive data line (RXD), a control line for the Data Set Ready (DSR), and a control line for the Data Terminal Ready (DTR). The DTE controls the DTR line to indicate that it is ready to transmit data, and the DCE controls the DSR line to indicate that it is ready to receive data.</p>
<p>The DTE and DCE also use other control lines such as Request to Send (RTS), Clear to Send (CTS), and Data Carrier Detect (DCD) to signal the readiness to transmit and receive data. By following the RS-232 standard, DTE and DCE devices can communicate with each other reliably and efficiently using asynchronous serial communication.</p>
</div>
<h3>Question 9</h3>
<div><p><p>What is the purpose of Programmable Peripheral Interface 8255A? Explain about its different ports.</p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p>The Programmable Peripheral Interface (PPI) 8255A is an integrated circuit that is used to interface input/output devices with a microprocessor. It is a versatile device that can be programmed to work in different modes to meet the requirements of various input/output devices.</p>
<p>The 8255A has three ports, Port A, Port B, and Port C. Each port can be used as either an input port or an output port, depending on the programming mode.</p>
<p><strong>Port A:</strong> Port A is an 8-bit bidirectional port that can be used for input or output operations. It can be programmed to work in two modes, Mode 0 and Mode 1. In Mode 0, Port A is used as two 4-bit input ports, while in Mode 1, it is used as one 8-bit input or output port.</p>
<p><strong>Port B:</strong> Port B is an 8-bit bidirectional port that can also be used for input or output operations. It can be programmed to work in three modes, Mode 0, Mode 1, and Mode 2. In Mode 0, Port B is used as two 4-bit input or output ports. In Mode 1, it is used as one 8-bit input or output port. In Mode 2, it is used as two 8-bit input or output ports, with one port being used for the high-order bits and the other for the low-order bits.</p>
<p><strong>Port C:</strong> Port C is a 4-bit port that can be used as either an input or output port. It can be programmed to work in two modes, Mode 0 and Mode 1. In Mode 0, Port C is used as four 1-bit input or output ports. In Mode 1, it is used as two 2-bit input or output ports, with one port being used for the high-order bits and the other for the low-order bits.</p>
<p>In addition to the three ports, the 8255A also has control registers that are used to program the device. These include Control Register A (CRA), Control Register B (CRB), and Control Register C (CRC). These registers are used to set the operating modes of the ports, configure the interrupt system, and perform other functions.</p>
<p>The purpose of the 8255A is to provide a flexible and configurable interface between a microprocessor and input/output devices. It allows for different modes of operation to be programmed, depending on the specific requirements of the input/output devices. By using the 8255A, input/output devices can be easily interfaced with a microprocessor, without the need for complex circuitry or custom hardware.</p>
</div>
<h3>Question 10</h3>
<div><p><p>Explain memory read operation with suitable figure.</p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p>In a computer system, the memory read operation is the process of retrieving data from a specific memory location. Here is a simplified diagram showing the memory read operation.</p>
<ol style="list-style-type:decimal;">
<li>The CPU sends the address of the memory location it wants to read to the memory using the address bus.</li>
<li>The memory uses the address to find the location in its memory array and sends the data back to the CPU using the data bus.</li>
<li>The CPU receives the data and uses it in the instruction that it is executing.</li>
</ol>
<p>It is important to note that the speed at which the memory read operation can be performed is determined by the speed of the memory bus and the memory&#8217;s access time. A faster memory bus and lower memory access time will result in a faster memory read operation.</p>
<p><span style="color: #273239;">Memory read operation transfers the desired word to address lines and activates the read control line. Description of memory read operation is given below:</span><img decoding="async" class="aligncenter" src="https://hamrocsit.com/wp-content/uploads/users/2452/1676375145-MRO.png" width="299" alt=""></p>
<p><span style="color: #273239;">In the above diagram initially, MDR can contain any garbage value and MAR is containing the 2003 memory address. After the execution of the read instruction, the data of memory location 2003 will be read and the MDR will get updated by the value of the 2003 memory location (3D).</span></p>
</div>
<h3>Question 11</h3>
<div><p><p>What are the different kinds buses? How and why de-multiplexing of buses is carried out in 8085.</p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p>In a computer system, a bus is a communication pathway that transfers data between different components such as the processor, memory, and input/output devices. Here are the different kinds of buses in a computer system:</p>
<ol style="list-style-type:decimal;">
<li>Address Bus: This is a unidirectional bus used by the CPU to send memory addresses to the memory or input/output devices. The width of the address bus determines the maximum amount of memory that the CPU can access.</li>
<li>Data Bus: This is a bidirectional bus used to transfer data between the CPU, memory, and input/output devices. The width of the data bus determines the maximum amount of data that can be transferred in a single operation.</li>
<li>Control Bus: This is a bidirectional bus used to control the flow of data and signals between the CPU, memory, and input/output devices. It includes signals for read and writes operations, interrupts requests, and clock signals.</li>
</ol>
<p>Each type of bus has its own specifications, such as bus width, clock speed, and data transfer rate, which determine its performance and compatibility with different components. The design of the bus architecture is a critical factor in the overall performance and efficiency of a computer system.</p>
<p>In the 8085 microprocessor, de-multiplexing of buses is carried out to separate the address bus and data bus. The address bus and data bus share the same pins on the microprocessor, but they are used for different purposes.</p>
<p>The address bus is used to specify the memory location or input/output port that the processor wants to access. It is a unidirectional bus, which means that data flows only in one direction, from the processor to the memory or input/output port. The address bus consists of 16 lines, A0-A15, which provide a maximum of 64 kilobytes of memory and input/output space.</p>
<p>The data bus, on the other hand, is bidirectional and is used to transfer data between the processor and memory or input/output devices. It consists of 8 lines, D0-D7, which can transfer a byte of data in one operation.</p>
<p>De-multiplexing of buses is carried out using a latch or flip-flop circuit, which separates the address and data signals. The latch circuit receives the address and data signals from the processor and stores the address signals temporarily, while allowing the data signals to pass through to the memory or input/output device.</p>
<p>The reason for de-multiplexing the buses is to increase the speed and efficiency of data transfer. By separating the address and data signals, the processor can access memory or input/output devices more quickly and efficiently, without having to wait for the data to be sent or received.</p>
<p>In summary, de-multiplexing of buses is carried out in the 8085 microprocessor to separate the address and data signals, which allows for faster and more efficient data transfer between the processor and memory or input/output devices.</p>
</div>
<h3>Question 12</h3>
<div><p><p>Write short notes on (Any TWO):</p>
<ol>
<li>LDT</li>
<li>DMA</li>
<li>Assemble directives</li>
</ol</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p><span style="text-decoration: underline;"><strong>Local Descriptor Table (LDT):</strong></span></p>
<p>The Local Descriptor Table (LDT) is a data structure used in the x86 architecture to implement memory protection and process isolation. It is a table of segment descriptors that define memory segments for a specific task or process.</p>
<p>Each segment descriptor in the LDT specifies the base address, limit, and access rights of a segment of memory that belongs to a specific task. These access rights determine the type of memory access allowed for the task, such as read, write, or execute permissions.</p>
<p>The LDT is typically used in a multi-tasking operating system to provide each task with its own memory space, isolated from other tasks. This helps ensure that each task cannot interfere with the memory of other tasks, and also provides a level of security by preventing unauthorized access to memory.</p>
<p>The LDT is stored in memory and is accessed using a selector, which is an index in the table. The selector is loaded into a segment register, such as the LDTR (LDT Register), which is used by the processor to locate and retrieve the appropriate segment descriptor from the LDT.</p>
<p>While the use of the LDT is still supported in modern x86 processors, it is typically not used in most operating systems. Instead, the Global Descriptor Table (GDT) is used to define memory segments for the entire system, and each task is given its own set of segment descriptors within the GDT. This provides greater flexibility and efficiency in managing memory and processes.</p>
<p><span style="text-decoration: underline;"><strong>Direct Memory Access(DMA):</strong></span></p>
<p>DMA stands for Direct Memory Access. It is designed by Intel to transfer data at the fastest rate. It allows the device to transfer the data directly to/from memory without any interference of the CPU.</p>
<p>Using a DMA controller, the device requests the CPU to hold its data, address, and control bus, so the device is free to transfer data directly to/from the memory. The DMA data transfer is initiated only after receiving the HLDA signal from the CPU.</p>
<p>Following is the sequence of operations performed by a DMA −</p>
<ul class="list">
<li>Initially, when any device has to send data between the device and the memory, the device has to send a DMA request (DRQ) to the DMA controller.</li>
<li>The DMA controller sends a Hold request (HRQ) to the CPU and waits for the CPU to assert the HLDA.</li>
<li>Then the microprocessor tri-states all the data bus, address bus, and control bus. The CPU leaves control over the bus and acknowledges the HOLD request through the HLDA signal.</li>
<li>Now the CPU is in a HOLD state and the DMA controller has to manage the operations over buses between the CPU, memory, and I/O devices.</li>
</ul>
<p><span style="text-decoration: underline;"><strong>c) Assemble directives:</strong></span></p>
<p>Assembly directives, also known as assembler directives or pseudo-ops, are commands used in assembly language to provide information to the assembler, rather than being instructions for the processor. These directives typically begin with a period (.) or a hash (#) symbol.</p>
<p>Here are some common assembly directives used in microprocessor programming:</p>
<ul style="list-style-type: square;">
<li>.ORG: Specifies the origin or starting address for the program or data.</li>
<li>.EQU: Assigns a value to a symbol or constant, which can be used in place of a numerical value throughout the program.</li>
<li>.DB/.DW/.DD: Declares data bytes, words, or double-words respectively, and initializes them with specified values.</li>
<li>.RESB/.RESW/.RESD: Reserves a specified number of bytes, words, or double-words respectively, without initializing them.</li>
<li>.EXTERN/.GLOBAL: Declares a symbol as external or global, respectively, allowing it to be used across different source files or modules.</li>
<li>.IFDEF/.IFNDEF: Tests whether a symbol is defined or not, respectively, and includes or excludes code based on the result.</li>
<li>.INCLUDE: Includes the contents of another file at the current location in the source code.</li>
<li>.MODEL: Specifies the memory model used by the program, such as small, medium, large, or flat memory models.</li>
</ul>
<p>These directives are not executed by the processor but are instead processed by the assembler during the assembly process to generate the object code. By using these directives, the programmer can provide additional information to the assembler and facilitate the generation of the object code.</p>
</div>
</body></html>