
    <html>
    <head>
        <meta charset="UTF-8">
        <title>OOPS Question Bank 2075 2075</title>
    </head>
    <body>
        <h1>OOPS Question Bank 2075 - 2075</h1>
        <p><strong>Full Marks:</strong> 60 + 20 + 20</p>
        <p><strong>Pass Marks:</strong> 24 + 8 + 8</p>
        <p><strong>Time:</strong> 3 hours</p>
    <h2>Group A: Attempts any TWO questions</h2><h3>Question 1</h3>
<div><p><p>Explain the concept of user-defined to user-defined data conversion routine located in the destination class.</p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p>User-defined to user-defined data conversion routines, also known as type conversion operators, allow the programmer to define how an instance of one user-defined data type can be converted to another user-defined data type. This can be useful when working with complex data types that have a similar structure but different names or representations.</p>
<p>These conversion routines are located in the destination class, which is the class that the user wants to convert their object to. The routine takes an object of the source class (the class that the user wants to convert from) as an argument and returns an object of the destination class.</p>
<p>Here&#8217;s an example in C++:</p>
<pre class="EnlighterJSRAW" data-enlighter-language="generic">class Celsius {
    double temp;
    
    public:
          Celsius(double t = 0.0) { temp = t; }
          operator Fahrenheit() const;
};

class Fahrenheit {
    double temp;

    public:
          Fahrenheit(double t = 0.0) { temp = t; }
         operator Celsius() const {
              return Celsius((temp - 32.0) * 5.0 / 9.0);
         }
};

Celsius::operator Fahrenheit() const {
    return Fahrenheit(temp * 9.0 / 5.0 + 32.0);
}</pre>
<p>In this example, we have two user-defined data types, Celsius and Fahrenheit, which represent temperature values in different scales. The Celsius class has a conversion routine that allows it to be converted to a Fahrenheit object, and the Fahrenheit class has a conversion routine that allows it to be converted to a Celsius object.</p>
<p>Now, suppose we have a Celsius object <code>c</code> and we want to convert it to Fahrenheit. We can simply use the conversion operator we defined:</p>
<pre class="EnlighterJSRAW" data-enlighter-language="generic">Celsius c(100.0);
Fahrenheit f = c;</pre>
<p>In this code, the conversion operator <code>operator Fahrenheit()</code> is called on the <code>c</code> object, which returns a Fahrenheit object. The Fahrenheit object is then assigned to the <code>f</code> variable using the copy constructor.</p>
<p>User-defined to user-defined data conversion routines can be a powerful tool for simplifying code and making it more readable. However, they should be used with care, as they can also make code harder to understand if used excessively or inappropriately.</p>
</div>
<h3>Question 2</h3>
<div><p><p>Depict the difference between private and public derivation. Explain derived class constructor with suitable program.</p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p>The difference between public and private declaration are</p>
<div class="table_wrapper" style="overflow-x:auto;"><table width="100%">
<thead>
<tr>
<th>Public</th>
<th>Private</th>
</tr>
</thead>
<tbody>
<tr>
<td>All the class members declared under public will be available to everyone.</td>
<td>The class members declared as private can be accessed only by the functions inside the class.</td>
</tr>
<tr>
<td>The data members and member functions declared public can be accessed by other classes too.</td>
<td>Only the member functions or the friend functions are allowed to access the private data members of a class.</td>
</tr>
<tr>
<td>The public members of a class can be accessed from anywhere in the program using the direct member access operator (.) with the object of that class.</td>
<td>They are not allowed to be accessed directly by any object or function outside the class.</td>
</tr>
</tbody>
</table></div>
<p>For multiple inheritance order of constructor call is, the base class’s constructors are called in the order of inheritance and then the derived class’s constructor.</p>
<pre class="EnlighterJSRAW" data-enlighter-language="generic">#include &lt;iostream&gt;
using namespace std;

class Parent1
{
    public:
        Parent1()
        {
            cout &lt;&lt; "Inside first base class" &lt;&lt; endl;
        }
};

class Parent2
{
    public:
        Parent2()
        {
            cout &lt;&lt; "Inside second base class" &lt;&lt; endl;
        }
};

class Child : public Parent1, public Parent2
{
    public:
        Child()
        {
            cout &lt;&lt; "Inside child class" &lt;&lt; endl;
        }
};


int main()
{
    Child obj1;
    return 0;
}</pre>
<p>The output of above program is</p>
<pre class="EnlighterJSRAW" data-enlighter-language="generic">Inside first base class
Inside second base class
Inside child class</pre>
</div>
<h3>Question 3</h3>
<div><p><p>Briefly explain the hierarchy of stream classes. Write a program that overloads extraction and insertion operators.</p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p>In C++ stream refers to the stream of characters that are transferred between the program thread and i/o.</p>
<p><em>Stream classes</em> in C++ are used to input and output operations on files and io devices. These classes have specific features and to handle input and output of the program.</p>
<p>The <strong>iostream.h</strong> library holds all the stream classes in the C++ programming language.</p>
<p><img data-recalc-dims="1" loading="lazy" decoding="async" class="wp-image-5207 aligncenter" src="https://i0.wp.com/hamrocsit.com/wp-content/uploads/2022/02/Heirarchy-of-Stream-Classess-in-iostream.h.jpg?resize=476%2C344&#038;ssl=1" alt="Heirarchy of Stream Classess in iostream.h" width="476" height="344" srcset="https://i0.wp.com/hamrocsit.com/wp-content/uploads/2022/02/Heirarchy-of-Stream-Classess-in-iostream.h.jpg?w=778&amp;ssl=1 778w, https://i0.wp.com/hamrocsit.com/wp-content/uploads/2022/02/Heirarchy-of-Stream-Classess-in-iostream.h.jpg?resize=768%2C555&amp;ssl=1 768w" sizes="auto, (max-width: 476px) 100vw, 476px" /></p>
<ol style="list-style-type:decimal;">
<li><strong>ios class</strong> is topmost class in the stream classes hierarchy. It is the base class for <strong>istream, ostream, </strong>and <strong>streambuf</strong> class.</li>
<li><strong>istream</strong> and <strong>ostream</strong> serves the base classes for <strong>iostream</strong> class. The class <strong>istream</strong> is used for input and <strong>ostream</strong> for the output.</li>
<li>Class <strong>ios</strong> is indirectly inherited to <strong>iostream</strong> class using <strong>istream</strong> and <strong>ostream</strong>. To avoid the duplicity of data and member functions of <strong>ios</strong> class, it is declared as virtual base class when inheriting in <strong>istream</strong> and <strong>ostream.</strong></li>
</ol>
<p><span style="text-decoration: underline;"><strong>Program Part:</strong></span></p>
<p>Below is the program that overwrite the extraction and insertion operator</p>
<pre class="EnlighterJSRAW" data-enlighter-language="generic">#include &lt;iostream&gt;
using namespace std;

class Complex
{
    private:
        int real, imag;

    public:
        Complex(int r = 0, int i = 0)
        {
            real = r;
            imag = i;
        }

    friend ostream &amp;operator&lt;&lt;(ostream &amp;out, const Complex &amp;c){
        out &lt;&lt; c.real;
        out &lt;&lt; "+i" &lt;&lt; c.imag &lt;&lt; endl;
        return out;
    }

    friend istream &amp;operator&gt;&gt;(istream &amp;in, Complex &amp;c){
        cout &lt;&lt; "Enter Real Part ";
        in &gt;&gt; c.real;
        cout &lt;&lt; "Enter Imaginary Part ";
        in &gt;&gt; c.imag;
        return in;
    }
};

int main()
{
    Complex c1;
    cin &gt;&gt; c1;
    cout &lt;&lt; "The complex object is ";
    cout &lt;&lt; c1;
    return 0;
}</pre>
<p>The output of above program is</p>
<pre class="EnlighterJSRAW" data-enlighter-language="generic">Enter Real Part 1
Enter Imaginary Part 2
The complex object is 1+i2</pre>
<p>&nbsp;</p>
<p>&nbsp;</p>
</div>
<h2>Group B: Attempts any EIGHT questions</h2><h3>Question 4</h3>
<div><p><p>Write a member function called <b>reverseit</b>() that reverses a string ( an array of character). Use a for loop that swaps the first and last characters, then the second and next-to last characters and so on. The string should be passed to <b>reverseit</b>() as an argument.</p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><pre class="EnlighterJSRAW" data-enlighter-language="generic">#include&lt;iostream&gt;
#include&lt;string.h&gt;

using namespace std;

void reverseit(char *p){

    int j;

    int len=strlen(p);

    j=len-1;

    for(int i = 0; i &lt; len / 2; i++){

        char a=p[i];
        p[i]=p[j];
        p[j]=a;
        j--;

    }

    cout&lt;&lt;"\nReverse Of String :";

    puts(p);

}

int main(){

    char str[50];

    char ch;

    cout&lt;&lt;"\nEnter The String : ";

    gets(str);

    reverseit(str);
    
    return 0;

}</pre>
<p>The output of above program is</p>
<pre class="EnlighterJSRAW" data-enlighter-language="generic">Enter The String : Suresh

Reverse Of String :hseruS</pre>
</div>
<h3>Question 5</h3>
<div><p><p>What is the principle reason for using default arguments in the function? Explain how missing arguments and default arguments are handled by the function simultaneously?</p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p>A function can be called without specifying all its arguments. But it does not work on any general function. The function declaration must provide default values for those arguments that are not specified. When the arguments are missing from function call , default value will be used for calculation.</p>
<p><strong>Example:</strong></p>
<pre class="EnlighterJSRAW" data-enlighter-language="generic">#include &lt;iostream&gt;

using namespace std;

int sum(int a, int b = 10, int c = 20);

int main()
{

    cout &lt;&lt; sum(11) &lt;&lt; endl;

    cout &lt;&lt; sum(11, 12) &lt;&lt; endl;

    cout &lt;&lt; sum(11, 12, 13) &lt;&lt; endl;

    return 0;
}

int sum(int a, int b, int c)
{

    int z;

    z = a + b + c;

    return z;
}</pre>
<p>The output of above program is</p>
<pre class="EnlighterJSRAW" data-enlighter-language="generic">41
43
36</pre>
</div>
<h3>Question 6</h3>
<div><p><p>“An overloaded function appears to perform different activities depending the kind of data send to it” Justify the statement with appropriate example.</p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p>In programming, overloading functions allow multiple functions with the same name to be defined with different input parameters. This enables the same function name to perform different actions depending on the type or number of arguments passed to it.</p>
<p>For example, consider a function called &#8220;calculate&#8221; that takes two arguments &#8211; the first argument is an integer and the second argument is a float. The function performs different calculations depending on the data types of the arguments passed to it. If the first argument is an integer and the second argument is a float, the function calculates the product of the two arguments. If the first argument is a float and the second argument is an integer, the function calculates the sum of the two arguments. The code for the function could look like this:</p>
<pre class="EnlighterJSRAW" data-enlighter-language="generic">float calculate(int num1, float num2){
  return num1 * num2;
}

float calculate(float num1, int num2){
  return num1 + num2;
}</pre>
<p>In this example, the &#8220;calculate&#8221; function is overloaded to perform different calculations depending on the data types of the arguments passed to it. When the first argument is an integer and the second argument is a float, the first version of the function is called, and when the first argument is a float and the second argument is an integer, the second version of the function is called.</p>
<p>By overloading functions, developers can write more concise and readable code that performs multiple actions with the same function name. It also improves the code&#8217;s flexibility, as the function can be used with different data types without having to write multiple functions with different names.</p>
</div>
<h3>Question 7</h3>
<div><p><p>Explain the default action of the copy constructor. Write a suitable program that demonstrates the technique of overloading the copy constructor.</p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p>A constructor is a special member function used to initialize objects of its class. It will be called automatically when the object is created.</p>
<p>A class with two or more construct functions with the same name but with different parameters or arguments and other data types is called  Constructor overloading.</p>
<p>A copy constructor is a method or member function which initialize an object using another object within the same class.</p>
<p><strong>Example:</strong></p>
<pre class="EnlighterJSRAW" data-enlighter-language="generic">#include &lt;iostream&gt;
using namespace std;

class ABC
{
    public:
        int x;

        // this is parameterized constructor
        ABC(int a){
            x = a;
        }

        // this is copy constructor
        ABC(ABC &amp;i){
            x = i.x;
        }
};

int main()
{
    // Calling the parameterized constructor.
    ABC a1(40);

    // Calling the copy constructor.
    ABC a2(a1);

    cout &lt;&lt; a2.x;
    return 0;
}</pre>
</div>
<h3>Question 8</h3>
<div><p><p>Briefly explain types of inheritance used in object oriented Programming.</p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p>In C++, inheritance is a process in which one object acquires all the properties and behaviors of its parent object automatically. In such way, you can reuse, extend or modify the attributes and behaviors which are defined in other class.</p>
<h2 class="h2">Types Of Inheritance</h2>
<ol class="points">
<li>Single inheritance</li>
<li>Multiple inheritance</li>
<li>Hierarchical inheritance</li>
<li>Multilevel inheritance</li>
<li>Hybrid inheritance</li>
</ol>
<h3>1. Single Inheritance</h3>
<p><strong>Single inheritance</strong> is defined as the inheritance in which a derived class is inherited from the only one base class.</p>
<p><img decoding="async" class="aligncenter" style="width: 253px; height: 181px;" src="data:image/webp;base64,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" alt="User Loaded Image | CSIT Guide" /></p>
<p><strong>Syntax:</strong></p>
<pre class="EnlighterJSRAW" data-enlighter-language="generic">class subclassname : accessspecifier superclassname {
    //class specific code;
};</pre>
<h3>2. Multiple Inheritance</h3>
<p>Multiple inheritance is a type of inheritance in which a class derives from more than one classes. As shown in the above diagram, class C is a subclass that has class A and class B as its parent.</p>
<p>In a real-life scenario, a child inherits from its father and mother.</p>
<p><img decoding="async" class="aligncenter" style="width: 226px; height: 161px;" src="data:image/webp;base64,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" alt="User Loaded Image | CSIT Guide" /></p>
<h3>3. Hierarchical Inheritance</h3>
<p>In hierarchical inheritance, more than one class inherits from a single base class.</p>
<p><img decoding="async" class="aligncenter" style="width: 216px; height: 154px;" src="data:image/webp;base64,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" alt="User Loaded Image | CSIT Guide" /></p>
<h3>4. Multilevel Inheritance</h3>
<p>In multilevel inheritance, a class is derived from another derived class. This inheritance can have as many levels as long as our implementation doesn’t go wayward. In the above diagram, class C is derived from Class B. Class B is in turn derived from class A.</p>
<p><img decoding="async" class="aligncenter" style="width: 250px; height: 178px;" src="data:image/webp;base64,UklGRnQFAABXRUJQVlA4IGgFAADwNACdASpeAfoAPlEokUYjoqGhJbEICHAKCWlu4XShHyOdcmlQ7/9AH/uuQH/M6VX1AOi59V7/Q5M74X/jPab/Qvxs51M8y+XfkB8pPx3+gbo3+y/lp+QG2AeB3+4fmh5gP6B+QHOZ/hP+H8UDlAP4Z/MP8j9wHvo/xP9c/Z7/De4D5f/5f9w+An+P/yb/R/272AOoS/X3/5hy0dWNYhwkUkRGAxqrZKx9o6sfaOoM8BpZYYKCjkiAMOc1UdWPtHVj7Q2uEJiIFX3Al+AzauOs2rjrG9qB8DqfBwoCOEhO4lY+0dWPtHVjTutG9aErb5DuvtHVj7Rv2rUOq1EL9DXIv8XkO6+0dWPtDattcZj+7TYgUEeUFBHlBBfNS3CAl0StLPq1deVuzauOs2qyBq0gRj51NSqP9m+q80+VuzauOs06fs8oKCPKCgjygfS0NSvMAfG5W/yHdfaOrH2jfxEPXhKX5m09SM84iqgKh3X2jqx9o4UF1CLg4v/fOmSU0+VuzauCAij1eDihGbEDXqo6sfaOrH2hbiYZMls3DrtNFWjqx9o6sfaO9Um0dWPtCgAA/v+uhJSnbXHheVU1qFQJVN8/yAsKkibMuUEm7/oaL3451pDLR1b/3/wZM2AJkKy1xElVsjz4E9Qfwhu6C9f8YqDOZnKsBFtuvRKHMhVFIsJQz/6XF2jFh/fyNH3/96q2dEvNmqiK1/JndiAc3P313FcXSf2tX16GBAK+s3v+sIJiGT511TXi6/oH1JGARfq49bdVOL0Rs8AHEmjYZEZvZFqppZ6dpc8W1qN/+KzgRc4k24LdsigjcvvzfX3j7vXlhN1TTbo96EK5c80oW4qDPCcbaVjUA2LozFmDpcpcQHX6BAIeoNVzpzWEJdCPjoftZepbX/bvK3eE2CDQHQWa+p8V/VoEB9s/zZKbK3UwC7VjfeVwj/jG4u2Oyun4eqt7zwkda1Ulyt+i/RDYnFUhwEEKrxhUqI0HE/1TZlg6q9BnnsZkzmku/bX2//Pf8GpB4SEl7TM+7PRL33IDhcy4wUa37O66kfqHAbnZuWMWN9Ocry4PIc8Wv9TR2W+87pe2H0f/kDyU+831uzQVE6lA5lLpcqjelNfsUjcK0O2P+UGX45V/6VoKTaLk/KWmUluoDMnKsSdNmh0SwlCAHrvgtcVOLIW9z01ON4qEgvE4AeYwqOlDYMUPXhgeimqcGcDPiwuJ1gWv3gsL3Q9sVE1TKuG9p9Gh8Mx+lnU3ggSdlHCwOl2EoMV3o96Mk4ifSItr3qDHeumffaEms9r7GSZSNdzls5uZaVZZ5xDwWYkf3rNy0fs9OWKDlmPWM97dX5pE3jT1JkgnScclNTsM7f7dPUJITkHbqnm375qvcZOZ9nRHZvg2vD8Xv5ulJdqGE4BMzu79lMX8EjsShYKOJP+jyvlD9rAMC5r26HzXx8fP4BMAPZK3+ZmG6vVUuwfpit4vKwSfAVP++grvMs1cgLedPR6Wy4IOR7NaYSpnxq/9G2SeHvnF04jjbroHGT7dXcr7su5X/butCArZRRel7pRrPRV9aHfRKgFdq9U0ONH9YvrSVvOm7BcvCnQoCHt8uzKLFH8q/ofYNNSGPwf5E+VtHRKjYtBldLBFhlU+agc8B7AAubrEcLf2H3Ogif17tHrIE9cLv1ttMgrzgYhwTHZdz+YxdUMDBNigK/Mn/juhxz93C6WQxZNQpCKRbNOrhy3F+4dVheQoHqBmz6d3sCNONAeA7ctd8//lC6YI93LZ/7DUkIPAQE/kJ3ks48aSNTc2kka7tAE8FKc4UXY3A3UONJObiBDEO28hR8BP6KC2s3nAqoXBbAAA" alt="User Loaded Image | CSIT Guide" /></p>
<h3>5. Hybrid Inheritance</h3>
<p>Hybrid inheritance is usually a combination of more than one type of inheritance. In the above representation, we have multiple inheritance (B, C, and D) and multilevel inheritance (A, B and D) to get a hybrid inheritance.</p>
<p><img decoding="async" class="aligncenter" style="width: 215px; height: 154px;" src="data:image/webp;base64,UklGRoYHAABXRUJQVlA4IHoHAAAQQgCdASpeAfoAPlEkkUUjoiIWOLQkOAUEtLdwuOIlMZyT+kHzPQ7/wN0BzOnqA3hb+AeoB+rvWw/5HJiPB38e/ELwL/qX4ydT734SMfUH65+Rf5Q+xL+FfELfwb+2/k/+POYo/of5Yf4z9u/Yc/QOQd/Ov7f+TvrAeHp4B7AH8H/oH+V/t37cf1X6Sv0j/Of4L9ov7B7Wfyn+df8D+4fAL/Hf5T/j/6b++H+B8A/6wexF+tRjh3e+abbAoBg6VnAbm2BQC/waNHF6XY6VWGGUoHMeAbHg0S4THBP66QrMhUVgBRM8l71XWbVp27kL5dRiuNzsGxVaHpcGcyqHM6gFrHJe2vDHZa5K+g0PbQZN2Ek5+KSWpSNNU9qjokDHGEZHSFAp6JDwR1AHYi073r9RRNzTfsGiWOXWLQUeKDxAK4TNHfBhYH8BgaayKXqqlI00K1JqJFxGNFBsyIorMHsng9q1ZtCKpSdE47g7hN8WkrUmkqiz1vNalVrUktF062ML1kQ8y0580TXgq7Ijr7T9f571DpCsyUwTBMFKPschkQUltDF5pEsPrZsywXGHSFZkF09KaxUcYVrS2bmSvmdVFfUF3NsCgGDpWcBm7U6E9cOGWGJU+f/atKmOAcDqqObxhWbVZXCsoPatV3jxD6MEzsfzpCsz1qCtZK7EcbadQCZK+1MCgGDkDNPUgXGHSFZtWrNq1ZtWlAAA/v94F2kXrDE89l0DUDGfadBh2R1WfnwVfRMCqN17hFfkkpZTKYFUSuG0djX/nzEWCneN+HHtLUmO9k5kWD6uH94GL3XVBJo+n0ojbDEwMjvM9hJFU1YdIWqYUbUl2r8Ab76J407TLja/wZdEACu0UjWNrMUADhc5DowIBvlSGoBnr+Q/L1fOgNS/hM0M5reybqdP4fv03r2HcS2HZVH1j/DMOVG29CMQmgZ1/FDN+mlhN0nuw1EnHqCoDecVRa7TRr8ID4lFiCKkgdzY9SEz/gfkVwYKeFeIHgEAJSDUlvolACp5H+qGFBtQDl/wJdV2XmPVO1h0PgQXiD8FxVL7GwO/aWdV/rdg9dWGf/D53Tvu+cjcoKZ9gqzgwMuhWN+qGQJtQHCllrVHGPcYPQyZbHO4zYB5Q4Gn+Ubka8wwfPRP3AlU59RG4B/nfp8MWRszYB5QcAzLnyQnmpPPXf/BUWvZKK5FulAGgtIx2Vh59d0/F+ODOqdxvE2Qiyz6NTpwg+vIsoQ5p3IVM5RCt7rMynUhzKDOGBVCFNHJeMkMv6URZG6cZ7gGi2EcydzN7s3hvpcxKbfYiBZ+CWOJ3wN7zayI9eOKz4fOK9nTcka97rFE8/RbHHGPfWIBTc6zOoGcHo5tpoCpDQnpYIUUXd9GtkD+OMWUH9K43QRN/92d8p1/+BQfByxq61ZPsEUnr5fT29jxQ+OveeJzcQdrbCxwwgiKfs6kp5SoJ9YGG2KwvRpah0RUQh3NvC6UgerLNLHwZG6CHzvZsvQizxQ1jdbfMHIQs++1BjBezoBBpY3vUUth0gWHG2yEsNWMgYgcnm4mfcpZK+Wi47aTC1Vi4pH2LW3R7Z2eQdyLjrOFzdzjwGaikckEbYHdR5gQH6rU5nBZKGWWVegj3TQV7vQrFv4Fbw17otB8teYM7+bMq4aw0VhR8bvm3G/TwhvIdiZIscKxXpYBvseqGp5/R1Yoqczf4VtC8YOXEBdnIG9+tBxvL4hLl/bSmit+G4MQXQa8cYYuat6ArB3VKAd/nOkGuUxhVLYZMjYPOalbSFkF9J5w8qATWKLWa8M66sYKzZDwtgceNR1i6KTwOJIrSPTyyxxDZxToT/jlV1ZnofbXj1eHgQDkUSsmrgyYPgrT554jXesGGuW5/QlOOh6FM2KN/qqOIEhTRrLkWb3QAlPbPKtUZr2mSQ5cynSL1YhDD6BLssJV2o578rimY7QMkGlNM4l5xYjNacJNm9miw8/Xo/jcgh6ViAZ7NPpHAoP466C+GUP7yJq0wEEjQiE1xYciarZTkdvCzIahE+BReOs1GQbfgWsjXqxeH7ENeWPWwdKq4LrqtfILhNNqZhRUd/O3SOkoZI+PCLejd+LzhGvzOrbp4jOt45yENlOV10iFTRTwkOs13unRNZxXV3Xdam4HPt09+vz/jRpy+qP6kEf/M5d+UkeGlkFjduQ54c1d4+CAUVt4WugtLkMxNI+DWbT8ifSqtnGsgZ0g6tQtH6V5TvyHGYF1jqyGYw+8K/mQwCA6KnPqhpM1LzplNfojHIHHIbv4u8REm13pGFaa0gpYOSnJ/aC6mWaerZ0Jd4gV1ajzK2iaAea+EyhIzAjbOOY0VUD9agpfUBF68MD+dqKv491ut4+WKUe5Tw/UsTGV8vdG60dHdVdVbFAKcoInW57dtC5HeUFO2sQ53JY9WVZIh8+KBiacvtmcZtoNBk5A1elg5eyWP6p85v8u197MhvLoZoRx00LFqCUTEdmMMEf6zg0quLVruNtmN/4/luSYexvwsQh0yDMxXg887vGQwV7s0Q/43gkRiEHlAipDC/0BfFQAAAA=" alt="User Loaded Image | CSIT Guide" /></p>
</div>
<h3>Question 9</h3>
<div><p><p>Create a real scenario where static data members are useful. Explain with suitable example.</p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p>Static data members are class members that are declared using the static keyword. There is only one copy of the static data member in the class, even if there are many class objects. This is because all the objects share the static data member. The static data member is always initialized to zero when the first class object is created.</p>
<p>The syntax of the static data members is given as follows −</p>
<pre class="EnlighterJSRAW" data-enlighter-language="generic">static data_type data_member_name;</pre>
<p><span style="text-decoration: underline;"><strong>Example:</strong></span></p>
<pre class="EnlighterJSRAW" data-enlighter-language="generic">#include &lt;iostream&gt;
#include &lt;string.h&gt;

using namespace std;

class Student
{
    private:
        int rollNo;
        char name[10];
        int marks;

    public:
        static int objectCount;
        Student()
        {
            objectCount++;
        }

        void getdata()
        {
            cout &lt;&lt; "Enter roll number: " &lt;&lt; endl;
            cin &gt;&gt; rollNo;
            cout &lt;&lt; "Enter name: " &lt;&lt; endl;
            cin &gt;&gt; name;
            cout &lt;&lt; "Enter marks: " &lt;&lt; endl;
            cin &gt;&gt; marks;
        }

        void putdata()
        {
            cout &lt;&lt; "Roll Number = " &lt;&lt; rollNo &lt;&lt; endl;
            cout &lt;&lt; "Name = " &lt;&lt; name &lt;&lt; endl;
            cout &lt;&lt; "Marks = " &lt;&lt; marks &lt;&lt; endl;
            cout &lt;&lt; endl;
        }
};

int Student::objectCount = 0;

int main(void)
{
    Student s1;
    s1.getdata();
    s1.putdata();
    Student s2;

    s2.getdata();
    s2.putdata();
    Student s3;

    s3.getdata();
    s3.putdata();
    cout &lt;&lt; "Total objects created = " &lt;&lt; Student::objectCount &lt;&lt; endl;
    return 0;
}</pre>
<p>The output of above program is</p>
<pre class="EnlighterJSRAW" data-enlighter-language="generic">Enter roll number: 1
Enter name: Suresh
Enter marks: 70

Roll Number = 1
Name = Suresh
Marks = 70

Enter roll number: 2
Enter name: Julian
Enter marks: 80

Roll Number = 2
Name = Julian
Marks = 80

Enter roll number: 3
Enter name: Rajesh
Enter marks: 90

Roll Number = 3
Name = Rajesh
Marks = 90

Total objects created = 3</pre>
</div>
<h3>Question 10</h3>
<div><p><p>Create a function called <b>swaps</b>() that interchanges the values of the two arguments sent to it (pass these arguments by reference).  Make the function into a template, so it can be used with all numerical data types (char, int, float, and so on). Write a main() program to exercise the function with several types.</p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><pre class="EnlighterJSRAW" data-enlighter-language="generic">#include &lt;iostream&gt;
using namespace std;

template &lt;class T&gt;

void swaps(T &amp;a, T &amp;b){

    T temp = a;
    a = b;
    b = temp;
}

int main(){

    int x1, y1;
    float x2, y2;

    cout &lt;&lt; "Enter two Integer numbers: ";
    cin &gt;&gt; x1;
    cin &gt;&gt; y1;

    cout &lt;&lt; "Enter two Floting numbers: ";
    cin &gt;&gt; x2;
    cin &gt;&gt; y2;

    cout &lt;&lt; "\nBefore Swap:" &lt;&lt; endl;

    cout &lt;&lt; "x1 = " &lt;&lt; x1 &lt;&lt; " y1 = " &lt;&lt; y1 &lt;&lt; endl;

    cout &lt;&lt; "x2 = " &lt;&lt; x2 &lt;&lt; " y2 = " &lt;&lt; y2 &lt;&lt; endl;

    swaps(x1, y1);
    swaps(x2, y2);

    cout &lt;&lt; "\nAfter Swap:" &lt;&lt; endl;

    cout &lt;&lt; "x1 = " &lt;&lt; x1 &lt;&lt; " y1 = " &lt;&lt; y1 &lt;&lt; endl;

    cout &lt;&lt; "x2 = " &lt;&lt; x2 &lt;&lt; " y2 = " &lt;&lt; y2 &lt;&lt; endl;

    return 0;
}</pre>
<p>The output of above program is</p>
<pre class="EnlighterJSRAW" data-enlighter-language="generic">Enter two Integer numbers: 2
5
Enter two Floting numbers: 2.2
4.4

Before Swap:
x1 = 2 y1 = 5
x2 = 2.2 y2 = 4.4

After Swap:
x1 = 5 y1 = 2
x2 = 4.4 y2 = 2.2</pre>
<p>&nbsp;</p>
<p>&nbsp;</p>
</div>
<h3>Question 11</h3>
<div><p><p>Explain how exceptions are used for handling C++ error in a systematic and OOP-oriented way with the design that includes multiple exceptions.</p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p>Exceptions are run-time anomalies or abnormal conditions that a program encounters during its execution. Exception Handling in C++ is a process to handle runtime errors. We perform exception handling so the normal flow of the application can be maintained even after runtime errors. In C++, we use 3 keywords to perform exception handling: try, catch, and throw</p>
<ul style="list-style-type: square;">
<li>The <code class="w3-codespan"><b>try</b></code> statement allows us to define a block of code to be tested for errors while it is being executed.</li>
<li>The <code class="w3-codespan"><b>throw</b></code> keyword throws an exception when a problem is detected, which lets us create a custom error.</li>
<li>The <code class="w3-codespan"><b>catch</b></code> statement allows us to define a block of code to be executed, if an error occurs in the try block.</li>
</ul>
<p><span style="text-decoration: underline;"><b>Syntax to handle multiple exceptions:</b></span></p>
<pre class="EnlighterJSRAW" data-enlighter-language="generic">try
{
    //your code
} catch(exceptionName e1){
    // catch block
} catch(exceptionName e2){
    // catch block
} catch(exceptionName en){
    // catch block
}</pre>
<p>The example of exception handling is</p>
<pre class="EnlighterJSRAW" data-enlighter-language="generic">#include &lt;iostream&gt;
using namespace std;

int main(){

    int a = 3;

    try
    {
        if (a == 1)
            throw a; // throwing integer exception

        else if (a == 2)
            throw 'A'; // throwing character exception

        else if (a == 3)
            throw 4.5; // throwing float exception
    }
    catch (int a){
        cout &lt;&lt; "\nInteger exception.";
    }catch (char ch){
        cout &lt;&lt; "\nCharacter exception.";
    }catch (float f){
        cout &lt;&lt; "\nFloat exception.";
    }
    cout &lt;&lt; "\nProgram End.";

    return 0;
}</pre>
<p><strong>Output:</strong></p>
<pre class="EnlighterJSRAW" data-enlighter-language="generic">Float exception.
Program End</pre>
</div>
<h3>Question 12</h3>
<div><p><p>How is character I/O different from Binary I/O? Explain with examples.</p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p>The difference between character I/O and binary I/O are</p>
<div class="table_wrapper" style="overflow-x:auto;"><table style="border-collapse: collapse; width: 100%; height: 240px;">
<tbody>
<tr style="height: 24px;">
<td style="width: 50%; height: 24px; text-align: center;"><strong>Character I/O</strong></td>
<td style="width: 50%; height: 24px; text-align: center;"><strong>Binary I/O</strong></td>
</tr>
<tr style="height: 72px;">
<td style="width: 50%; height: 72px;">In text file, text, character, numbers are stored one character per byte i.e. 32667 occupies 5 bytes even though it occupies 2 bytes in memory.</td>
<td style="width: 50%; height: 72px;">In binary file data is stored in binary format and each data would occupy the same number of bytes on disks as it occupies in memory.</td>
</tr>
<tr style="height: 72px;">
<td style="width: 50%; height: 72px;">In the text file, the newline character is converted to carriage-return/linefeed before being written to the disk.</td>
<td style="width: 50%; height: 72px;">In binary file, conversion of newline to carriage-return and linefeed does not take place.</td>
</tr>
<tr style="height: 24px;">
<td style="width: 50%; height: 24px;">Text files are used to store data more user friendly.</td>
<td style="width: 50%; height: 24px;">Binary files are used to store data more compactly.</td>
</tr>
<tr style="height: 24px;">
<td style="width: 50%; height: 24px;">In the text file, a special character whose ASCII value is 26 inserted after the last character to mark the end of file.</td>
<td style="width: 50%; height: 24px;">In the binary file no such character is present. Files keep track of the end of the file from the number of characters present.</td>
</tr>
<tr style="height: 24px;">
<td style="width: 50%; height: 24px;">Content written in text files is human readable.</td>
<td style="width: 50%; height: 24px;">Content written in binary files is not human readable and looks like encrypted content.</td>
</tr>
</tbody>
</table></div>
<p>An example to open, read and write to a text file</p>
<pre class="EnlighterJSRAW" data-enlighter-language="generic">#include &lt;fstream&gt;
#include &lt;iostream&gt;
using namespace std;
  
int main () {
    char data[100];
    
    ofstream myfile;
    myfile.open("hello.txt");
  
    cout &lt;&lt; "Writing to the file" &lt;&lt; endl;
    cout &lt;&lt; "Enter your name: ";
    cin.getline(data, 100);
  
    myfile &lt;&lt; data &lt;&lt; endl;
  
    cout &lt;&lt; "Enter your age: "; cin &gt;&gt; data;
    cin.ignore();
  
    myfile &lt;&lt; data &lt;&lt; endl;
    
    myfile.close();
    
    ifstream infile;
    infile.open("hello.txt");
  
    cout &lt;&lt; "Reading from a file" &lt;&lt; endl; 
    infile &gt;&gt; data;
  
    cout &lt;&lt; data &lt;&lt; endl; infile &gt;&gt; data;
    cout &lt;&lt; data &lt;&lt; endl;
  
    infile.close();
    
    return 0;
}</pre>
<p>An example to read and write to a binary file</p>
<pre class="EnlighterJSRAW" data-enlighter-language="generic">#include &lt;iostream&gt;
#include &lt;fstream&gt;

using namespace std;
struct Student{
    int roll_no;
    string name;
};

int main(){

    ofstream wf("student.dat", ios::out | ios::binary);

    if (!wf){
        cout &lt;&lt; "Cannot open file!" &lt;&lt; endl;
        return 1;
    }

    Student wstu[3];
    wstu[0].roll_no = 1;
    wstu[0].name = "Suresh";
    wstu[1].roll_no = 2;
    wstu[1].name = "Rajesh";
    wstu[2].roll_no = 3;
    wstu[2].name = "Prince";

    for (int i = 0; i &lt; 3; i++)
        wf.write((char *)&amp;wstu[i], sizeof(Student));

    wf.close();

    if (!wf.good()){
        cout &lt;&lt; "Error occurred while writing!" &lt;&lt; endl;
        return 1;
    }

    ifstream rf("student.dat", ios::out | ios::binary);

    if (!rf){
        cout &lt;&lt; "Cannot open binary file!" &lt;&lt; endl;
        return 1;
    }

    Student rstu[3];
    for (int i = 0; i &lt; 3; i++)
        rf.read((char *)&amp;rstu[i], sizeof(Student));
    rf.close();

    if (!rf.good()){
        cout &lt;&lt; "Error occurred while reading!" &lt;&lt; endl;
        return 1;
    }

    cout &lt;&lt; "Student's Details:" &lt;&lt; endl;
    for (int i = 0; i &lt; 3; i++){
        cout &lt;&lt; "Roll No: " &lt;&lt; wstu[i].roll_no &lt;&lt; endl;
        cout &lt;&lt; "Name: " &lt;&lt; wstu[i].name &lt;&lt; endl;
        cout &lt;&lt; endl;
    }

    return 0;
}</pre>
<p>&nbsp;</p>
<p>&nbsp;</p>
</div>
</body></html>