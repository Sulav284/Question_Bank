
    <html>
    <head>
        <meta charset="UTF-8">
        <title>DAA Question Bank 2081 2081</title>
    </head>
    <body>
        <h1>DAA Question Bank 2081 - 2081</h1>
        <p><strong>Full Marks:</strong> 60 + 20 + 20</p>
        <p><strong>Pass Marks:</strong> 24 + 8 + 8</p>
        <p><strong>Time:</strong> 3 hours</p>
    <h2>Section A: Attempt any TWO questions.</h2><h3>Question 1</h3>
<div><p><p>Differentiate between dynamic programming and memorization. Compute the shortest path between every pairs in the following graphs using Floyd Warshal algorithm.</p>
<p><img data-recalc-dims="1" loading="lazy" decoding="async" class="alignnone size-full wp-image-59837" src="https://i0.wp.com/hamrocsit.com/wp-content/uploads/2025/04/Screenshot-2025-04-28-at-4.55.17%E2%80%AFPM.png?resize=428%2C268&ssl=1" alt="" width="428" height="268"></p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p>The differences between dynamic programming and memorization are as follows:</p>
<div class="table_wrapper" style="overflow-x:auto;"><table style="border-collapse: collapse; width: 100%;">
<tbody>
<tr>
<td style="width: 50%;">Dynamic Programming</td>
<td style="width: 50%;">Memorization</td>
</tr>
<tr>
<td style="width: 50%;">1. Dynamic Programming is the research of finding an optimized plan to a problem through finding the best substructure of the problem for reusing the computation results.</td>
<td style="width: 50%;">1. Memorization is the technique to &#8220;remember&#8221; the result of a computation, and reuse it the next time instead of recomputing it, to save time.</td>
</tr>
<tr>
<td style="width: 50%;">2. Dynamic programming is bottom-up approach.</td>
<td style="width: 50%;">2. Memorization is top-down approach.</td>
</tr>
<tr>
<td style="width: 50%;">3. Code gets complicated when lot of conditions are required.</td>
<td style="width: 50%;">3. Code is easy and less complicated.</td>
</tr>
<tr>
<td style="width: 50%;">4. Slow due to lot of recursive calls and return statements.</td>
<td style="width: 50%;">4. It is fast, as we directly access previous states.</td>
</tr>
<tr>
<td style="width: 50%;">5. It is preferable when the original problem requires all subproblems to be solved.</td>
<td style="width: 50%;">5. It is preferable when the original problem requires only some subproblems to be solved.</td>
</tr>
<tr>
<td style="width: 50%;">6. In Dynamic Programming, all subproblems are solved even if they are not needed later (since it works bottom-up).</td>
<td style="width: 50%;">6. In Memoization, only the subproblems that are actually required are solved (since it works top-down and computes on demand).</td>
</tr>
</tbody>
</table></div>
<p>These are the differences between dynamic programming and memorization.</p>
<p><img data-recalc-dims="1" loading="lazy" decoding="async" class="alignnone size-full wp-image-59838" src="https://i0.wp.com/hamrocsit.com/wp-content/uploads/2025/04/CamScanner-04-28-2025-16.24n_1.jpg?resize=1804%2C2512&#038;ssl=1" alt="" width="1804" height="2512"> <img data-recalc-dims="1" loading="lazy" decoding="async" class="alignnone size-medium wp-image-59839" src="https://i0.wp.com/hamrocsit.com/wp-content/uploads/2025/04/CamScanner-04-28-2025-16.24n_2.jpg?resize=1576%2C2192&#038;ssl=1" alt="" width="1576" height="2192"> <img data-recalc-dims="1" loading="lazy" decoding="async" class="alignnone size-medium wp-image-59840" src="https://i0.wp.com/hamrocsit.com/wp-content/uploads/2025/04/CamScanner-04-28-2025-16.24n_3.jpg?resize=1736%2C964&#038;ssl=1" alt="" width="1736" height="964"></p>
</div>
<h3>Question 2</h3>
<div><p><p>What is the worst case of quick sort and how does randomize quick sort handle this problem? Sort the data { -2, 4, -3, 6, 12, 10, 11, 13, 9 } using quick sort.</p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p>As its name implies, quick sort is a fast divide-and-conquer algorithm. It has two phases: the partition phase and the sort phase.</p>
<p>Divide: Partition the array A[l&#8230;r] into two sub-arrays A[l&#8230;pivot] and A[pivot+1&#8230;r], such that each element of A[l&#8230;pivot] is smaller than or equal to each element in A[pivot+1&#8230;r].</p>
<p>Conquer: Recursively sort A[l&#8230;pivot] and A[pivot+1&#8230;r] using quick sort.</p>
<p>Combine: The arrays are sorted in place. No additional work is required to combine them.</p>
<p><span style="text-decoration: underline;">Time Complexity:</span></p>
<p>In Best Case, time complexity T(n) = O(n log n).</p>
<p>In Worst Case, time complexity T(n) = O(n²).</p>
<p>In Average Case, time complexity T(n) = O(n log n).</p>
<p>&nbsp;</p>
<p>The worst case of Quick Sort happens when the pivot chosen always results in the most unbalanced partitions — for example, when the array is already sorted (either ascending or descending) and the pivot is always the smallest or largest element. In this case, Quick Sort has to make n recursive calls each reducing the problem size by only one, leading to a time complexity of O(n²).</p>
<p>Randomized Quick Sort solves this problem by picking the pivot randomly instead of using a fixed strategy like choosing the first or last element. Because the pivot is random, it is highly unlikely to always pick the worst pivot repeatedly, and thus the expected time complexity becomes O(n log n), even for inputs that would cause worst-case behavior in regular Quick Sort.</p>
<p><span style="text-decoration: underline;">Pseudo code:</span></p>
<p><code>RandPartition(A, l, r){</code></p>
<p><code>k = random(l, r); // generates random number between l and r</code><br />
<code>swap(A[l], A[k]);</code><br />
<code>return Partition(A, l, r);</code><br />
<code>}</code></p>
<p><code>RandQuickSort(A, l, r)</code><br />
<code>{</code><br />
<code>if (l &lt; r)</code><br />
<code>{</code><br />
<code>m = RandPartition(A, l, r);</code><br />
<code>RandQuickSort(A, l, m-1);</code><br />
<code>RandQuickSort(A, m+1, r);</code><br />
<code>}</code><br />
<code>}</code></p>
</div>
<h3>Question 3</h3>
<div><p><p>Does greedy algorithm guarantee optimal solution? Solve the Fractional knapsack problem to find maximum loot from given information.</p>
<div class="table_wrapper"><table>
<tbody>
<tr>
<td>Item</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
</tr>
<tr>
<td>Value</td>
<td>12</td>
<td>10</td>
<td>20</td>
<td>15</td>
<td>2</td>
<td>3</td>
<td>50</td>
</tr>
<tr>
<td>Weight (kgs)</td>
<td>2</td>
<td>1</td>
<td>3</td>
<td>2</td>
<td>12</td>
<td>10</td>
<td>1</td>
</tr>
</tbody>
</table></div</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p>Greedy algorithms do not always guarantee optimal solution. It depends on the type of problem. But, for certain problems, it guarantees optimal solution. However, greedy algorithms can still be useful because they are often fast and easy to implement, and they can sometimes provide a good approximation of the optimal solution.</p>
<p>Greedy algorithms guarantee optimal solutions only if the problem has:</p>
<p>1. Greedy Choice Property: A global optimum can be arrived at by choosing a local optimum.</p>
<p>2. Optimal Substructure: The optimal solution of the problem contains optimal solutions to its subproblems.</p>
<p>&nbsp;</p>
<p><img data-recalc-dims="1" loading="lazy" decoding="async" class="alignnone size-full wp-image-59842" src="https://i0.wp.com/hamrocsit.com/wp-content/uploads/2025/04/CamScanner-04-28-2025-16.24n_4.jpg?resize=1560%2C2140&#038;ssl=1" alt="" width="1560" height="2140"></p>
</div>
<h2>Section B: Attempt any EIGHT questions.</h2><h3>Question 4</h3>
<div><p><p>Given a set A=(5,7,10,12,15,18,20}, find the subset that sum to 35 using backtracking.</p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p><img data-recalc-dims="1" loading="lazy" decoding="async" class="alignnone size-full wp-image-59821" src="https://i0.wp.com/hamrocsit.com/wp-content/uploads/2025/04/CamScanner-04-28-2025-16.24n_5.jpg?resize=2216%2C1552&#038;ssl=1" alt="" width="2216" height="1552"></p>
</div>
<h3>Question 5</h3>
<div><p><p>Solve the following recurrence relations using master’s method.</p>
<p>(a)<br />
\[<br />
T(n) = 2T\left( \frac{n}{2} \right) + n^3, \quad n > 1<br />
\]<br />
\[<br />
T(n) = 1, \quad n = 1<br />
\]</p>
<p>(b)<br />
\[<br />
T(n) = 2T\left( \frac{n}{4} \right) + 1, \quad n > 1<br />
\]<br />
\[<br />
T(n) = 1, \quad n = 1<br />
\]</p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p><img data-recalc-dims="1" loading="lazy" decoding="async" class="alignnone size-full wp-image-59825" src="https://i0.wp.com/hamrocsit.com/wp-content/uploads/2025/04/CamScanner-04-28-2025-16.24n_6.jpg?resize=1412%2C1940&#038;ssl=1" alt="" width="1412" height="1940"></p>
</div>
<h3>Question 6</h3>
<div><p><p>Write an algorithm to find the n<sup>th</sup> fibonacci number with its time and space complexity.</p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p><span style="text-decoration: underline;">Algorithm </span></p>
<p>Step 1: Start</p>
<p>Step 2: If n == 0, return 0. If n == 1, return 1.</p>
<p>Step 3: Initialize first = 0 and second = 1.</p>
<p>Step 4: For i = 2 to n, do:</p>
<p>Set temp = first + second</p>
<p>Set first = second</p>
<p>Set second = temp</p>
<p>Step 5: After loop ends, return second.</p>
<p>Step 6: End</p>
<p><span style="text-decoration: underline;">Pseudo code:</span></p>
<p><code>Fibonacci(n)</code><br />
<code>{</code><br />
<code>if (n == 0)</code><br />
<code>return 0;</code><br />
<code>else if (n == 1)</code><br />
<code>return 1;</code></p>
<p><code>first = 0;</code><br />
<code>second = 1;</code></p>
<p><code></code><code>for (i = 2; i &lt;= n; i++)</code><br />
<code>{</code><br />
<code>temp = first + second;</code><br />
<code>first = second;</code><br />
<code>second = temp;</code><br />
<code>}</code><br />
<code>return second;</code><br />
<code>}</code></p>
<p>Time Complexity:</p>
<p>The time complexity of the code is O(n) because it uses a single loop that runs from 2 up to 𝑛, performing a constant amount of work in each iteration.</p>
<p>Space Complexity:</p>
<p>The space complexity is O(1) because it only uses a few fixed variables (first, second, temp, and i) and does not require any additional data structures like arrays or recursion stacks.</p>
</div>
<h3>Question 7</h3>
<div><p><p>Define order statistics problem. Find the edit distance between “cat” and “car” using dynamic programming.</p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p>Order statistics are sample values placed in ascending order. The study of order statistics deals with the application of these ordered values and their functions.</p>
<p><span style="text-decoration: underline;">Definition</span>: Given a set A of n elements, i<sup>th </sup>order statistics gives the i<sup>th</sup> smallest(or largest) element in the set.</p>
<p><span style="text-decoration: underline;">Problem:</span></p>
<p>Input: An array A of n distinct elements.</p>
<p>Output: An element e which belongs to A such that e is larger than exactly i-1 elements.</p>
<p>Example: A = {28, 50, 10, 5, 7, 9, 15, 25}</p>
<p>First order statistics = minimum value element of A = 5<br />
Fifth order statistics = 15</p>
<p>A median is given by i<sup>th</sup> order statistic where<br />
i = (n + 1) / 2 for odd n<br />
and i = n / 2 for even n</p>
<p><img data-recalc-dims="1" loading="lazy" decoding="async" class="alignnone size-full wp-image-59827" src="https://i0.wp.com/hamrocsit.com/wp-content/uploads/2025/04/CamScanner-04-28-2025-16.24n_7.jpg?resize=1572%2C2220&#038;ssl=1" alt="" width="1572" height="2220"></p>
</div>
<h3>Question 8</h3>
<div><p><p>Discuss about recursion and backtracking. Analyze the complexity of Miller Rabin Randomized Primality test.</p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p>Backtracking</p>
<p>Backtracking is an algorithmic technique that considers all the possible outcomes to solve any computational problem. It involves algorithm to find the solution of the computational problem. Backtracking is like a top-down process. Example: backtracking is used in algorithms like BFS, DFS etc.</p>
<p>Recursion</p>
<p>Recursion is the process of breaking down a problem into smaller sub problems such that it can be solved trivially. Unlike backtracking, it involves a function which calls itself. Recursion is like a bottom-up process. Example: recursion is used to solve recursive problems like factorial, gcd etc.</p>
<p><span style="text-decoration: underline;">Miller Rabin Primality test:</span></p>
<p>This algorithm is used to determine whether a given number is prime or not.</p>
<p><span style="text-decoration: underline;">Algorithm</span>: /* It returns false if n is composite and returns true if n<br />
is probably prime. k is an input parameter that determines<br />
accuracy level. Higher value of k indicates more accuracy. */</p>
<p>bool IsPrime(int n, int k)<br />
1) Handle base cases for n ≤ 3<br />
2) If n is even, return false.<br />
3) Find an odd number d such that n &#8211; 1 can be written as d * 2^r.<br />
Note that since n is odd, (n &#8211; 1) must be even and r must be<br />
greater than 0.<br />
4) Do following k times<br />
if (millerTest(n, d) == false)<br />
return false<br />
5) Return true;</p>
<p>bool millerTest(int n, int d)<br />
1) Pick a random number ‘a’ in range [2, n − 2]<br />
2) Compute: x = pow(a, d) % n</p>
<p>3) If x == 1 or x == n &#8211; 1, return true.</p>
<p>// Below loop mainly runs &#8216;r &#8211; 1&#8217; times.<br />
4) Do following while d doesn&#8217;t become n &#8211; 1,<br />
a) x = (x * x) % n<br />
b) If (x == 1) return false.<br />
c) If (x == n &#8211; 1) return true.</p>
<p>Time complexity:</p>
<p>The time complexity of the Miller-Rabin primality test is O(k × log³n), where n is the number being tested and k is the number of iterations. This is because each iteration involves modular exponentiation and a loop of repeated squaring, both of which take logarithmic time relative to n.</p>
<p>Space complexity:</p>
<p>The space complexity is O(1) since the algorithm uses only a fixed number of variables and does not require any additional memory that grows with the input size.</p>
</div>
<h3>Question 9</h3>
<div><p><p>Solve the following linear equation using Chinese Remainder Theorem.</p>
<p>x = 1 MOD 3</p>
<p>x = 2 MOD 5</p>
<p>x = 0 MOD 7</p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p><img data-recalc-dims="1" loading="lazy" decoding="async" class="alignnone size-full wp-image-59832" src="https://i0.wp.com/hamrocsit.com/wp-content/uploads/2025/04/CamScanner-04-28-2025-16.24n_8.jpg?resize=1532%2C2120&#038;ssl=1" alt="" width="1532" height="2120"> <img data-recalc-dims="1" loading="lazy" decoding="async" class="alignnone size-medium wp-image-59833" src="https://i0.wp.com/hamrocsit.com/wp-content/uploads/2025/04/CamScanner-04-28-2025-16.24n_9.jpg?resize=1496%2C2032&#038;ssl=1" alt="" width="1496" height="2032"></p>
</div>
<h3>Question 10</h3>
<div><p><p>Explain the approximation algorithm for vertex cover of a connected graph with an example.</p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p>A Vertex Cover of a graph G is a set of vertices such that each edge in G is incident to at least one of these vertices. Now we want to find a minimum size vertex cover of a given graph. We call such vertex cover an optimal vertex cover C*.<br />
The idea is to take an edge (u, v) one by one, put both vertices to C, and remove all the edges incident to u or v. We carry on until all edges have been removed.</p>
<p><img data-recalc-dims="1" loading="lazy" decoding="async" class="alignnone size-full wp-image-59887" src="https://i0.wp.com/hamrocsit.com/wp-content/uploads/2025/04/WhatsApp-Image-2025-04-29-at-11.18.57%E2%80%AFAM.jpeg?resize=920%2C1280&#038;ssl=1" alt="" width="920" height="1280"></p>
<p>&nbsp;</p>
</div>
<h3>Question 11</h3>
<div><p><p>State cooks theorem. Discuss about problem reducibility.</p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p>Cook&#8217;s theorem states that the Boolean satisfiability problem is NP-complete. That is, any problem in NP can be reduced in polynomial time by a deterministic Turing machine to the problem of determining whether a Boolean formula is satisfiable.</p>
<p>An important consequence of this theorem is that if there exists a deterministic polynomial time algorithm for solving Boolean satisfiability, then every NP problem can be solved by a deterministic polynomial time algorithm. The question of whether such an algorithm for Boolean satisfiability exists is thus equivalent to the P versus NP problem, which is widely considered the most unsolved problem in theoretical computer science.</p>
</div>
<h3>Question 12</h3>
<div><p><p>Write short notes on:</p>
<p>a) Big Oh, Big Omega, Big theta</p>
<p>b) Class P, Class NP and NP-Complete</p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p>a) Big Oh, Big Omega, Big theta</p>
<p><img data-recalc-dims="1" loading="lazy" decoding="async" class="alignnone size-full wp-image-59897" src="https://i0.wp.com/hamrocsit.com/wp-content/uploads/2025/04/Screenshot-2025-04-29-at-12.41.36%E2%80%AFPM.png?resize=1678%2C1292&#038;ssl=1" alt="" width="1678" height="1292"></p>
<p><img data-recalc-dims="1" loading="lazy" decoding="async" class="alignnone size-full wp-image-59898" src="https://i0.wp.com/hamrocsit.com/wp-content/uploads/2025/04/Screenshot-2025-04-29-at-12.42.40%E2%80%AFPM.png?resize=1536%2C1276&#038;ssl=1" alt="" width="1536" height="1276"></p>
<p><img data-recalc-dims="1" loading="lazy" decoding="async" class="alignnone size-full wp-image-59899" src="https://i0.wp.com/hamrocsit.com/wp-content/uploads/2025/04/Screenshot-2025-04-29-at-12.43.31%E2%80%AFPM.png?resize=1612%2C1160&#038;ssl=1" alt="" width="1612" height="1160"></p>
<p>&nbsp;</p>
<p>b) Class P, Class NP and NP-Complete</p>
<p><img data-recalc-dims="1" loading="lazy" decoding="async" class="alignnone size-full wp-image-59900" src="https://i0.wp.com/hamrocsit.com/wp-content/uploads/2025/04/Screenshot-2025-04-29-at-12.45.05%E2%80%AFPM.png?resize=1660%2C1116&#038;ssl=1" alt="" width="1660" height="1116"></p>
<p><img data-recalc-dims="1" loading="lazy" decoding="async" class="alignnone size-full wp-image-59901" src="https://i0.wp.com/hamrocsit.com/wp-content/uploads/2025/04/Screenshot-2025-04-29-at-12.46.07%E2%80%AFPM.png?resize=1702%2C682&#038;ssl=1" alt="" width="1702" height="682"></p>
</div>
</body></html>