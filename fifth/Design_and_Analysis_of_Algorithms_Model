
    <html>
    <head>
        <meta charset="UTF-8">
        <title>DAA Model question 0</title>
    </head>
    <body>
        <h1>DAA Model question - 0</h1>
        <p><strong>Full Marks:</strong> 60 + 20 + 20</p>
        <p><strong>Pass Marks:</strong> 24 + 8 + 8</p>
        <p><strong>Time:</strong> 3 hours</p>
    <h2>SECTION A: Attempt any TWO question.</h2><h3>Question 1</h3>
<div><p><p>Write down the elements of dynamic programming. Give the recursive defination of LCS problem. Find LCS between sequences S1 = “Dinesh”, S2 = “Dikshya”.</p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p>Dynamic programming is an algorithm or technique which give optimal solution to the complex problem by breking them into simple sub-problems. This algorithm has the following elements:</p>
<ul style="list-style-type: square;">
<li><strong>Optimal structure</strong> : This element of dynamic programming means that if we have an optimal solution to the sub-problems of the problem then optimal solution to the problem can be constructed. The property of giving optimal solution from the optimal sub-solution is optimal structure.</li>
<li><strong>Overlapping sub-problems</strong> : Reusing the simpler sub-problem muliple-times and storing their results to avoid redundant computation. If the recursive algorith would visit the same sub-problem repeatedly, then a problem has overlapping sub-problem.</li>
</ul>
<p><strong>Longest Common Subsequence (LCS)</strong> is a classic problem in computer science. It refers to finding the longest subsequence that is common to two or more sequences. LCS between two sequences is the longest sequence that appears in both sequences in the same relative order, but not necessarily contiguously.</p>
<p><strong>Numerical part</strong> :</p>
<p>given, sequences</p>
<p>S1 = &#8220;Dinesh&#8221;</p>
<p>S2 = &#8220;Dikshya&#8221;</p>
<p>Let,</p>
<p>X<sub>1 </sub>= D  , X<sub>2 </sub>= I , X<sub>3 </sub>= K  , X<sub>4 </sub>= S , X<sub>5 </sub>= H , X<sub>6 </sub>= Y  , X<sub>7 </sub>=  A</p>
<p>Y<sub>1 </sub>= D , Y<sub>2</sub><sub> </sub>= I , Y<sub>3</sub><sub> </sub>= N , Y<sub>4</sub><sub> </sub>= E , Y<sub>5</sub><sub> </sub>= S , Y<sub>6</sub><sub> </sub>= H</p>
<p>i = 7 and j = 6</p>
<p>C(i, j)  = 0   for (i = 0 to 7 ) i.e C[i, 0] = 0</p>
<p>Also, C(i, j)  = 0   for (j = 0 to 6 ) i.e C[0, j] = 0</p>
<p>so, filling those part of table with zero</p>
<ul style="list-style-type: square;">
<li><strong>for C (i, j) = C (1, 1)</strong></li>
</ul>
<p>now,</p>
<p>as i&gt;0 i.e 1&gt;0 and also j&gt;0 i.e 1&gt;0  also X<sub>1 </sub>= Y<sub>1</sub>  i.e D = D so,</p>
<p>= C(i-1, j-1) +1</p>
<p>= C(1-1, 1-1) +1</p>
<p>= C(0, 0) +1  = 0 + 1 = 1</p>
<p>the direction will be up left.</p>
<ul style="list-style-type: square;">
<li><strong>for C (i, j) = C (1, 2)</strong></li>
</ul>
<p>now,</p>
<p>as i&gt;0 i.e 1&gt;0 and also j&gt;0 i.e 2&gt;0 and X<sub>1</sub> ≠ Y<sub>1</sub> i.e D ≠ I so,</p>
<p>MAX (C(i-1 , j) , C(i , j-1)) = MAX (C(1-1 , 2) , C(1 , 2-1))</p>
<p>= MAX (C(0 , 2) , C(1 , 1)) = MAX (0, 1) = 1</p>
<p>Here,C(i-1 , j) &lt;  C(i , j-1) i.e 0 &lt; 1. Hence, the direction will be left.</p>
<ul style="list-style-type: square;">
<li><strong>for C (i, j) = C (1, 3)</strong></li>
</ul>
<p>now,</p>
<p>as i&gt;0 i.e 1&gt;0 and also j&gt;0 i.e 3&gt;0 and X<sub>1</sub> ≠ Y<sub>1</sub> i.e D ≠ N so,</p>
<p>MAX (C(i-1 , j) , C(i , j-1)) = MAX (C(1-1 , 3) , C(1 , 3-1))</p>
<p>= MAX (C(0 , 3) , C(1 , 2)) = MAX (0, 1) = 1</p>
<p>Here,C(i-1 , j) &lt;  C(i , j-1) i.e 0 &lt; 1. Hence, the direction will be left.</p>
<ul style="list-style-type: square;">
<li><strong>for C (i, j) = C (1, 4)</strong></li>
</ul>
<p>now,</p>
<p>as i&gt;0 i.e 1&gt;0 and also j&gt;0 i.e 4&gt;0 and X<sub>1</sub> ≠ Y<sub>1</sub> i.e D ≠ E so,</p>
<p>MAX (C(i-1 , j) , C(i , j-1)) = MAX (C(1-1 , 4) , C(1 , 4-1))</p>
<p>= MAX (C(0 , 4) , C(1 , 3)) = MAX (0, 1) = 1</p>
<p>Here,C(i-1 , j) &lt;  C(i , j-1) i.e 0 &lt; 1. Hence, the direction will be left.</p>
<ul style="list-style-type: square;">
<li><strong>for C (i, j) = C (1, 5)</strong></li>
</ul>
<p>now,</p>
<p>as i&gt;0 i.e 1&gt;0 and also j&gt;0 i.e 5&gt;0 and X<sub>1</sub> ≠ Y<sub>1</sub> i.e D ≠ S so,</p>
<p>MAX (C(i-1 , j) , C(i , j-1)) = MAX (C(1-1 , 5) , C(1 , 5-1))</p>
<p>= MAX (C(0 , 5) , C(1 , 4)) = MAX (0, 1) = 1</p>
<p>Here,C(i-1 , j) &lt;  C(i , j-1) i.e 0 &lt; 1. Hence, the direction will be left.</p>
<ul style="list-style-type: square;">
<li><strong>for C (i, j) = C (1, 6)</strong></li>
</ul>
<p>now,</p>
<p>as i&gt;0 i.e 1&gt;0 and also j&gt;0 i.e 6&gt;0 and X<sub>1</sub> ≠ Y<sub>1</sub> i.e D ≠ H so,</p>
<p>MAX (C(i-1 , j) , C(i , j-1)) = MAX (C(1-1 , 6) , C(1 , 6-1))</p>
<p>= MAX (C(0 , 6) , C(1 , 5)) = MAX (0, 1) = 1</p>
<p>Here,C(i-1 , j) &lt;  C(i , j-1) i.e 0 &lt; 1. Hence, the direction will be left.</p>
<ul style="list-style-type: square;">
<li><strong>for C (i, j) = C (2, 1)</strong></li>
</ul>
<p>now,</p>
<p>as i&gt;0 i.e 2&gt;0 and also j&gt;0 i.e 1&gt;0 and X<sub>1</sub> ≠ Y<sub>1</sub> i.e I ≠ D so,</p>
<p>MAX (C(i-1 , j) , C(i , j-1)) = MAX (C(2-1 , 1) , C(2 , 1-1))</p>
<p>= MAX (C(1 , 1) , C(2 , 0)) = MAX (1, 0) = 1</p>
<p>Here,C(i-1 , j) &gt;  C(i , j-1) i.e 1 &gt; 0. Hence, the direction will be up.</p>
<ul style="list-style-type: square;">
<li><strong>for C (i, j) = C (2, 2)</strong></li>
</ul>
<p>now,</p>
<p>as i&gt;0 i.e 1&gt;0 and also j&gt;0 i.e 1&gt;0  also X<sub>1 </sub>= Y<sub>1</sub>  i.e I = I so,</p>
<p>= C(i-1, j-1) +1</p>
<p>= C(2-1, 2-1) +1</p>
<p>= C(1, 1) +1  = 1 + 1 = 2</p>
<p>the direction will be up left.</p>
<ul style="list-style-type: square;">
<li><strong>for C (i, j) = C (2, 3)</strong></li>
</ul>
<p>now,</p>
<p>as i&gt;0 i.e 2&gt;0 and also j&gt;0 i.e 3&gt;0 and X<sub>1</sub> ≠ Y<sub>1</sub> i.e I ≠ N so,</p>
<p>MAX (C(i-1 , j) , C(i , j-1)) = MAX (C(2-1 , 2) , C(2 , 3-1))</p>
<p>= MAX (C(1 , 3) , C(2 , 2)) = MAX (1, 2) = 2</p>
<p>Here,C(i-1 , j) &lt;  C(i , j-1) i.e 1 &lt; 2. Hence, the direction will be left.</p>
<ul style="list-style-type: square;">
<li><strong>for C (i, j) = C (2, 4)</strong></li>
</ul>
<p>now,</p>
<p>as i&gt;0 i.e 2&gt;0 and also j&gt;0 i.e 4&gt;0 and X<sub>1</sub> ≠ Y<sub>1</sub> i.e I ≠ E so,</p>
<p>MAX (C(i-1 , j) , C(i , j-1)) = MAX (C(2-1 , 4) , C(2 , 4-1))</p>
<p>= MAX (C(1 , 4) , C(2 , 3)) = MAX (1, 2) = 2</p>
<p>Here,C(i-1 , j) &lt;  C(i , j-1) i.e 1 &lt; 2. Hence, the direction will be left.</p>
<ul style="list-style-type: square;">
<li><strong>for C (i, j) = C (2, 5)</strong></li>
</ul>
<p>now,</p>
<p>as i&gt;0 i.e 2&gt;0 and also j&gt;0 i.e 5&gt;0 and X<sub>1</sub> ≠ Y<sub>1</sub> i.e I ≠ S so,</p>
<p>MAX (C(i-1 , j) , C(i , j-1)) = MAX (C(2-1 , 5) , C(2 , 5-1))</p>
<p>= MAX (C(1 , 5) , C(2 , 4)) = MAX (1, 2) = 2</p>
<p>Here,C(i-1 , j) &lt;  C(i , j-1) i.e 1 &lt; 2. Hence, the direction will be left.</p>
<ul style="list-style-type: square;">
<li><strong>for C (i, j) = C (2, 6)</strong></li>
</ul>
<p>now,</p>
<p>as i&gt;0 i.e 2&gt;0 and also j&gt;0 i.e 6&gt;0 and X<sub>1</sub> ≠ Y<sub>1</sub> i.e I ≠ H so,</p>
<p>MAX (C(i-1 , j) , C(i , j-1)) = MAX (C(2-1 , 6) , C(2 , 6-1))</p>
<p>= MAX (C(1 , 6) , C(2 , 5)) = MAX (1, 2) = 2</p>
<p>Here,C(i-1 , j) &lt;  C(i , j-1) i.e 1 &lt; 2. Hence, the direction will be left.</p>
<p>So on repeating for 3, 4, 5, 6 and 7 we get different values and filling the table as</p>
<p>&nbsp;</p>
<p style="text-align: center;"><img data-recalc-dims="1" loading="lazy" decoding="async" class="alignnone wp-image-39851" src="https://i0.wp.com/hamrocsit.com/wp-content/uploads/2024/08/LCS.drawio.png?resize=444%2C317&#038;ssl=1" alt="" width="444" height="317"></p>
<p>Hence the LCS (Longest Common Sequence) of sequence &#8220;Dikshya&#8221; and &#8220;Dinesh&#8221; is 4.</p>
</div>
<h3>Question 2</h3>
<div><p><p>What is heap? Sort the following data items by using heap sort A[] = {3, 5, 2, 66, 4, 11, 9, 34}.</p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p>Heap is almost binary tree whose elements have key that satisfy the following condition:</p>
<ul style="list-style-type: square;">
<li>The key along path from root to leaf are descending.</li>
<li>Heap could represent family descended tree because the heap property means that every parent is older than its children.</li>
</ul>
<p>STEP 1 : Converting the array to tree.</p>
<p><img data-recalc-dims="1" loading="lazy" decoding="async" class="wp-image-39857 aligncenter" src="https://i0.wp.com/hamrocsit.com/wp-content/uploads/2024/08/heap-1.drawio.png?resize=257%2C190&#038;ssl=1" alt="" width="257" height="190"></p>
<p>&nbsp;</p>
<p>STEP 2 : Converting the tree to min heap.</p>
<p><img data-recalc-dims="1" loading="lazy" decoding="async" class="wp-image-39858 aligncenter" src="https://i0.wp.com/hamrocsit.com/wp-content/uploads/2024/08/heap-2.drawio.png?resize=414%2C152&#038;ssl=1" alt="" width="414" height="152"></p>
<p>STEP 3 :</p>
<p><img data-recalc-dims="1" loading="lazy" decoding="async" class="wp-image-39859 aligncenter" src="https://i0.wp.com/hamrocsit.com/wp-content/uploads/2024/08/heap-3.drawio.png?resize=423%2C155&#038;ssl=1" alt="" width="423" height="155"></p>
<p>STEP 4 :</p>
<p><img data-recalc-dims="1" loading="lazy" decoding="async" class="wp-image-39861 aligncenter" src="https://i0.wp.com/hamrocsit.com/wp-content/uploads/2024/08/heap.drawio.png?resize=476%2C175&#038;ssl=1" alt="" width="476" height="175"></p>
<p>&nbsp;</p>
<div class="table_wrapper" style="overflow-x:auto;"><table style="border-collapse: collapse; width: 100%;">
<tbody>
<tr>
<td style="width: 12.5%; text-align: center;">2</td>
<td style="width: 12.5%; text-align: center;">4</td>
<td style="width: 12.5%; text-align: center;">3</td>
<td style="width: 12.5%; text-align: center;">34</td>
<td style="width: 12.5%; text-align: center;">5</td>
<td style="width: 12.5%; text-align: center;">11</td>
<td style="width: 12.5%; text-align: center;">9</td>
<td style="width: 12.5%; text-align: center;">66</td>
</tr>
</tbody>
</table></div>
<p>&nbsp;</p>
<p>STEP 5 : Deleting the elements from root to get sorted heap.</p>
<p><img data-recalc-dims="1" loading="lazy" decoding="async" class="alignnone size-full wp-image-39863" src="https://i0.wp.com/hamrocsit.com/wp-content/uploads/2024/08/heap5.drawio.png?resize=1326%2C233&#038;ssl=1" alt="" width="1326" height="233"></p>
<p style="text-align: center;">Deleted : 2,</p>
<p>STEP 6 : Deleting the elements from root to get sorted heap.</p>
<p><img data-recalc-dims="1" loading="lazy" decoding="async" class="size-full wp-image-39864 aligncenter" src="https://i0.wp.com/hamrocsit.com/wp-content/uploads/2024/08/heap-6.drawio.png?resize=1699%2C241&#038;ssl=1" alt="" width="1699" height="241"></p>
<p style="text-align: center;">Deleted : 2, 3,</p>
<p>STEP 7 : Deleting the elements from root to get sorted heap.</p>
<p><img data-recalc-dims="1" loading="lazy" decoding="async" class="wp-image-39865 aligncenter" src="https://i0.wp.com/hamrocsit.com/wp-content/uploads/2024/08/heap-7.drawio.png?resize=406%2C120&#038;ssl=1" alt="" width="406" height="120"></p>
<p style="text-align: center;">Deleted : 2, 3, 4</p>
<p>STEP 8 : Deleting the elements from root to get sorted heap.</p>
<p><img data-recalc-dims="1" loading="lazy" decoding="async" class="wp-image-39866 aligncenter" src="https://i0.wp.com/hamrocsit.com/wp-content/uploads/2024/08/heap-8.drawio.png?resize=457%2C135&#038;ssl=1" alt="" width="457" height="135"></p>
<p style="text-align: center;">Deleted : 2, 3, 4, 5</p>
<p>STEP 9 : Deleting the elements from root to get sorted heap.</p>
<p><img data-recalc-dims="1" loading="lazy" decoding="async" class="wp-image-39867 aligncenter" src="https://i0.wp.com/hamrocsit.com/wp-content/uploads/2024/08/heap-9.drawio.png?resize=434%2C99&#038;ssl=1" alt="" width="434" height="99"></p>
<p style="text-align: center;">Deleted : 2, 3, 4, 5, 9</p>
<p>STEP 10 : Deleting the elements from root to get sorted heap.</p>
<p><img data-recalc-dims="1" loading="lazy" decoding="async" class="wp-image-39868 aligncenter" src="https://i0.wp.com/hamrocsit.com/wp-content/uploads/2024/08/heap-10.drawio.png?resize=99%2C107&#038;ssl=1" alt="" width="99" height="107"></p>
<p style="text-align: center;">Deleted : 2, 3, 4, 5, 9, 11</p>
<p>STEP 10 : Deleting the elements from root to get sorted heap.</p>
<p><img data-recalc-dims="1" loading="lazy" decoding="async" class="alignnone size-full wp-image-39869 aligncenter" src="https://i0.wp.com/hamrocsit.com/wp-content/uploads/2024/08/heap-11.drawio.png?resize=52%2C52&#038;ssl=1" alt="" width="52" height="52"></p>
<p style="text-align: center;">Deleted : 2, 3, 4, 5, 9, 11, 34</p>
<p>STEP 11 : After deleting all element from root we get sorted array as</p>
<p style="text-align: center;">{2, 3, 4, 5, 9, 11, 34, 66}</p>
</div>
<h3>Question 3</h3>
<div><p><p>Given a set S ={6, 4, 5, 6, 9} and X=11. Obtain the subset sum using backtracking approach.</p>
<p> </p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p>given,</p>
<p>S ={6, 4, 5, 6, 9}</p>
<p>X=11</p>
<p>&nbsp;</p>
<p><img data-recalc-dims="1" loading="lazy" decoding="async" class="alignnone wp-image-39958" src="https://i0.wp.com/hamrocsit.com/wp-content/uploads/2024/08/subsetsum.drawio.png?resize=578%2C203&#038;ssl=1" alt="" width="578" height="203"></p>
<p>&nbsp;</p>
</div>
<h2>SECTION B: Attempt any EIGHT question.</h2><h3>Question 4</h3>
<div><p><p>Write down algorithm of insertion sort and analyze its time and space complexity.</p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p><strong>Algorithm</strong></p>
<p>InsertionSort(arr):<br />
n = length of arr</p>
<p>for i from 1 to n-1:<br />
key = arr[i]<br />
j = i &#8211; 1</p>
<p># Move elements of arr[0..i-1] that are greater than key to one position ahead of their current position<br />
while j &gt;= 0 and arr[j] &gt; key:<br />
arr[j + 1] = arr[j]<br />
j = j &#8211; 1</p>
<p>arr[j + 1] = key</p>
<p><strong>Time Complexity:</strong></p>
<ul style="list-style-type: square;">
<li style="list-style-type: none;">
<ul style="list-style-type: square;">
<li>In the worst-case scenario, where the input array is in reverse order, each element must be compared and moved to its correct position in each iteration of the outer loop.</li>
<li>The worst-case time complexity is <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathnormal">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n<sup>2</sup></span></span><span class="mclose">)</span></span></span></span></span>, where <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathnormal">n</span></span></span></span></span> is the number of elements in the array.</li>
<li>In the best-case scenario, where the input array is already sorted, the algorithm has a linear time complexity of <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathnormal">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>.</li>
</ul>
</li>
</ul>
<p><strong>Space Complexity:</strong></p>
<p>The space complexity is <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathnormal">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span> because insertion sort operates in-place. It uses only a constant amount of extra space for the key and loop control variables.</p>
</div>
<h3>Question 5</h3>
<div><p><p>Define binary search algorithm. Write down the recursive algorithm for binary search algorithm and analyse it.</p>
<p> </p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p>Binary Search Algorithm is a searching algorithm used in a sorted array by repeatedly dividing the search interval in half. The idea of binary search is to use the information that the array is sorted and reduce the time complexity.</p>
<p><strong>Algorithm :</strong></p>
<p>Binary_Search(a, l, r, key)</p>
<p>{</p>
<p>int m;</p>
<p>int flag =0;</p>
<p>if (l&lt;=r)</p>
<p>{</p>
<p>m = (l+r)/2;</p>
<p>if(key = =a[m])</p>
<p>flag = m;</p>
<p>elesif (key&lt;a[m])</p>
<p>return Binary_Search(a, l, m-1, key);</p>
<p>else</p>
<p>return Binary_Search(a, m+1, r, key);</p>
<p>}</p>
<p>else</p>
<p>return flag;</p>
<p>}</p>
<p><strong>Analysis :</strong></p>
<p>From the above algorith we can say that the running time of algorithm is T(n) = T(n/2) +O(1).</p>
<p>By any one of the recurrance relation solving technique we get, T(n) = O(log n).</p>
<p>In best case output time complexity is O(1).</p>
<p>In worst case output time complexity is O(log n).</p>
<p>In average case output time complexity is O(log n).</p>
</div>
<h3>Question 6</h3>
<div><p><p>Explain the asymptotic notations used to describe the time/space complexity of any algorithm.</p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><h4>Big Oh Notation (O):</h4>
<p>Big-Oh notation is used to define the <span style="text-decoration: underline;">upper bound</span> of an algorithm in terms of Time Complexity. It always indicates the maximum time required by an algorithm for all input values. It describes the worst case of an algorithm time complexity.</p>
<p><strong>Example:</strong> Find Big oh of the given function f(n) = 3n<sup>2</sup> + 4n + 7</p>
<p><strong>solution:</strong> We have f(n) = 3n<sup>2</sup> + 4n + 7 &lt;= 3n<sup>2</sup> + 4n<sup>2</sup>+7n<sup>2</sup> &lt;= 14n<sup>2</sup></p>
<p>f(n) &lt;= 14n<sup>2</sup></p>
<p>where c = 14 and g(n) = n<sup>2</sup>, thus f(n) = O(g(n)) = O(n<sup>2</sup>)</p>
<p>&nbsp;</p>
<h4 class="bsc-question">Big – Omege Notation (Ω):</h4>
<p>Big-Omega notation is used to define the<span style="text-decoration: underline;"> lower bound</span> of an algorithm in terms of Time Complexity. It always indicates the minimum time required by an algorithm for all input values. It describes the best case of an algorithm time complexity.</p>
<p><strong>Example:</strong> Find Big oh of the given function f(n) = 3n<sup>2</sup> + 4n + 7</p>
<p><strong>Solution: </strong>we have f(n) = 3n<sup>2</sup> + 4n + 7 &gt;= 3n<sup>2</sup></p>
<p>f(n) = 3n<sup>2</sup></p>
<p>where c = 14 and g(n) = n<sup>2</sup>, thus f(n) = Ω(g(n)) = Ω(n<sup>2</sup>)</p>
<p>&nbsp;</p>
<h4 class="bsc-question">Big-Theta Notation (Θ):</h4>
<p>Big-Theta notation is used to define the <span style="text-decoration: underline;">average bound</span> of an algorithm in terms of Time Complexity. It indicates the average time required by an algorithm for all input values. It describes the average case of an algorithm time complexity.</p>
<p><strong>Example:</strong> If f(n) = 3n<sup>2</sup> + 4n + 7 g(n) = n<sup>2</sup>, then prove that f(n) = Θ(g(n))</p>
<p><strong>solution: </strong>Let us consider c<sub>1</sub>, c<sub>2,</sub> and n<sub>0</sub> values as 14, 1, and 1 respectively then we can have,</p>
<p>f(n) &lt;= c<sub>1</sub> * g(n), n &gt;= n<sub>0</sub> as 3n<sup>2</sup> + 4n + 7  &lt;= 14n<sup>2</sup>, and</p>
<p>f(n) &lt;= c<sub>2</sub> * g(n), n &gt;= n<sub>0</sub> as 3n<sup>2</sup> + 4n + 7  &lt;= 1n<sup>2</sup>, and</p>
<p>For all n &gt;= 1 (in both cases)</p>
<p>so, c<sub>2</sub> *g(n) &lt;= f(n) &lt;= c<sub>1</sub> * g(n) is trival</p>
<p>Hence, f(n) = Θ(g(n))</p>
</div>
<h3>Question 7</h3>
<div><p><p>What is the purpose of Euclid’s algorithm? Explain with suitable explain.</p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p>The Euclidean Algorithm is a technique for quickly finding the GCD of two integers  by dividing the larger by the smaller, the smaller by the remainder.</p>
<p>Purpose of Euclid&#8217;s Algorithm:</p>
<ul style="list-style-type: square;">
<li>The GCD obtained using the Euclidean algorithm can be used to simplify fractions.</li>
<li>It&#8217;s a fundamental tool in algorithms like RSA for finding multiplicative inverses.</li>
<li>Helps in solving linear equations, which have applications in number theory and algebra.</li>
<li>The algorithm is often used in computer programs to perform tasks that involve GCD computations.</li>
</ul>
<p>Example of Euclid&#8217;s Algorithm:</p>
<p style="text-align: center;">EUCLID (30, 21)</p>
<p style="text-align: center;">= EUCLID(21, 30 MOD 21)</p>
<p style="text-align: center;">= EUCLID(21, 9)</p>
<p style="text-align: center;">= EUCLID(9, 21 MOD 9)</p>
<p style="text-align: center;">= EUCLID(9, 3)</p>
<p style="text-align: center;">= EUCLID(3, 9 MOD 3)</p>
<p style="text-align: center;">= EUCLID(3, 0)</p>
<p>Since, b==0 so return a = 3. Hence GCD(21, 30) = 3</p>
</div>
<h3>Question 8</h3>
<div><p><p>Solve the recurrence relation T(n) = T(n-1) + 1 when T(0) = 0.</p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p>given,</p>
<p style="text-align: center;">T(n) = 1            when n = 0</p>
<p style="text-align: center;">T(n) = T(n-1) + 1</p>
<p>Now,</p>
<p style="text-align: center;">T(n) = T(n-1) + 1 &#8212;&#8212;&#8212;&#8212;- i</p>
<p>let,</p>
<p style="text-align: center;">n = n-1</p>
<p>substuting value of n in eqn i</p>
<p style="text-align: center;">T(n-1) = T((n-1)-1) ++ 1</p>
<p style="text-align: center;">           T(n-1) = T(n-2) + 1 &#8212;&#8212;&#8212;&#8212;- a</p>
<p>Re-substuting the value of n in eq a we get,</p>
<p style="text-align: center;">T(n-2) = T((n-1)-2) + 1</p>
<p style="text-align: center;">         T(n-2) = T(n-3) + 1 &#8212;&#8212;&#8212;&#8212;- b</p>
<p>by itetration method from eq 1, a and b we get,</p>
<p style="text-align: center;">T(n) = T(n-1) + 1</p>
<p>placing value of n-1 in eq i we get,</p>
<p style="text-align: center;">T(n) = [T(n-2) + 1] + 1</p>
<p style="text-align: center;">T(n) =T(n-2) + 2</p>
<p style="text-align: center;">T(n) = [T(n-3) + 1] + 2</p>
<p style="text-align: center;">T(n) = T(n-3) + 3</p>
<p>from this we can predict the pattern of k<sup>th </sup>term</p>
<p style="text-align: center;">T(n) = T(n-k) + k</p>
<p>At some instance k will be equal to n so n-k will be 0 and,</p>
<p>we already have T(0) = 0 then,</p>
<p style="text-align: center;">n &#8211; k =0</p>
<p style="text-align: center;">n = k</p>
<p>Then the general form will be :</p>
<p style="text-align: center;">T(n) = T(n-k) + k</p>
<p style="text-align: center;">T(n) = T(n-n) + n</p>
<p style="text-align: center;">T(n) = T(0) + n</p>
<p style="text-align: center;">T(n) = 1 + n</p>
<p>Hence,</p>
<p>T(n) = O(n + 1)</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p style="text-align: center;">T(n) =T(n-2) + T(n-3)+ T(n-4) + T(n-5) + 3</p>
</div>
<h3>Question 9</h3>
<div><p><p>Define greedy algorithm. Find minimum spanning tree of the following graph by using Kruskal algorithm.</p>
<p><img data-recalc-dims="1" loading="lazy" decoding="async" class=" wp-image-6460 aligncenter" src="https://i0.wp.com/hamrocsit.com/wp-content/uploads/2022/06/ds-qnbank-2078-kruskal.jpg?resize=351%2C195&ssl=1" alt="" width="351" height="195" srcset="https://i0.wp.com/hamrocsit.com/wp-content/uploads/2022/06/ds-qnbank-2078-kruskal.jpg?w=900&ssl=1 900w, https://i0.wp.com/hamrocsit.com/wp-content/uploads/2022/06/ds-qnbank-2078-kruskal.jpg?resize=768%2C427&ssl=1 768w" sizes="auto, (max-width: 351px) 100vw, 351px" /></p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p>A <b><strong>greedy algorithm</strong></b> is a type of optimization algorithm that makes locally optimal choices at each step to find a globally optimal solution. It operates on the principle of “taking the best option now” without considering the long-term consequences.</p>
<p>&nbsp;</p>
<p><span style="text-decoration: underline;"><strong>Numerical Part:</strong></span></p>
<p><img data-recalc-dims="1" loading="lazy" decoding="async" class=" wp-image-6460 aligncenter" src="https://i0.wp.com/hamrocsit.com/wp-content/uploads/2022/06/ds-qnbank-2078-kruskal.jpg?resize=351%2C195&#038;ssl=1" alt="" width="351" height="195" srcset="https://i0.wp.com/hamrocsit.com/wp-content/uploads/2022/06/ds-qnbank-2078-kruskal.jpg?w=900&amp;ssl=1 900w, https://i0.wp.com/hamrocsit.com/wp-content/uploads/2022/06/ds-qnbank-2078-kruskal.jpg?resize=768%2C427&amp;ssl=1 768w" sizes="auto, (max-width: 351px) 100vw, 351px" /></p>
<p>Listing all the edges with its weight in ascending order.</p>
<div class="table_wrapper" style="overflow-x:auto;"><table style="border-collapse: collapse; width: 100.163%;">
<tbody>
<tr>
<td style="width: 25%; text-align: center;">SN</td>
<td style="width: 25%; text-align: center;">Edge</td>
<td style="width: 25%; text-align: center;">Weight</td>
<td style="width: 25.173%; text-align: center;">Selection</td>
</tr>
<tr>
<td style="width: 25%; text-align: center;">1</td>
<td style="width: 25%; text-align: center;">1,4</td>
<td style="width: 25%; text-align: center;">1</td>
<td style="width: 25.173%; text-align: center;">yes</td>
</tr>
<tr>
<td style="width: 25%; text-align: center;">2</td>
<td style="width: 25%; text-align: center;">1,2</td>
<td style="width: 25%; text-align: center;">2</td>
<td style="width: 25.173%; text-align: center;">yes</td>
</tr>
<tr>
<td style="width: 25%; text-align: center;">3</td>
<td style="width: 25%; text-align: center;">2,4</td>
<td style="width: 25%; text-align: center;">3</td>
<td style="width: 25.173%; text-align: center;">no</td>
</tr>
<tr>
<td style="width: 25%; text-align: center;">4</td>
<td style="width: 25%; text-align: center;">2,3</td>
<td style="width: 25%; text-align: center;">3</td>
<td style="width: 25.173%; text-align: center;">yes</td>
</tr>
<tr>
<td style="width: 25%; text-align: center;">5</td>
<td style="width: 25%; text-align: center;">1,5</td>
<td style="width: 25%; text-align: center;">4</td>
<td style="width: 25.173%; text-align: center;">yes</td>
</tr>
<tr>
<td style="width: 25%; text-align: center;">6</td>
<td style="width: 25%; text-align: center;">4,3</td>
<td style="width: 25%; text-align: center;">5</td>
<td style="width: 25.173%; text-align: center;">no</td>
</tr>
<tr>
<td style="width: 25%; text-align: center;">7</td>
<td style="width: 25%; text-align: center;">2,6</td>
<td style="width: 25%; text-align: center;">7</td>
<td style="width: 25.173%; text-align: center;">yes</td>
</tr>
<tr>
<td style="width: 25%; text-align: center;">8</td>
<td style="width: 25%; text-align: center;">3,6</td>
<td style="width: 25%; text-align: center;">8</td>
<td style="width: 25.173%; text-align: center;">no</td>
</tr>
<tr>
<td style="width: 25%; text-align: center;">9</td>
<td style="width: 25%; text-align: center;">5,4</td>
<td style="width: 25%; text-align: center;">9</td>
<td style="width: 25.173%; text-align: center;">no</td>
</tr>
</tbody>
</table></div>
<p style="text-align: center;"><img data-recalc-dims="1" loading="lazy" decoding="async" class="alignnone size-full wp-image-41679 aligncenter" src="https://i0.wp.com/hamrocsit.com/wp-content/uploads/2024/08/Untitled-Diagram.drawio.png?resize=361%2C201&#038;ssl=1" alt="" width="361" height="201"><br />
weight = 1+2+3+4+7 = 17 .</p>
</div>
<h3>Question 10</h3>
<div><p><p>Explain in brief about the classes P, NP, and NP complete with examples.</p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p><strong><u>P Class</u></strong></p>
<p>The P in the P class stands for <strong>Polynomial Time.</strong> It is the collection of decision problems(problems with a “yes” or “no” answer) that can be solved by a deterministic machine in polynomial time.</p>
<p><strong>eatures:</strong></p>
<ol style="list-style-type:decimal;">
<li>The solution to P problems is easy to find.</li>
<li>P is often a class of computational problems that are solvable and tractable. Tractable means that the problems can be solved in theory as well as in practice. But the problems that can be solved in theory but not in practice are known as intractable.</li>
</ol>
<p>This class contains many natural problems like:</p>
<ol style="list-style-type:decimal;">
<li><strong>Calculating the greatest common divisor.</strong></li>
<li><strong>Finding a maximum matching.</strong></li>
<li><strong>Decision versions of linear programming.</strong></li>
</ol>
<p><strong><u>NP Class</u></strong></p>
<p>The NP in NP class stands for <strong>Non-deterministic Polynomial Time</strong>. It is the collection of decision problems that can be solved by a non-deterministic machine in polynomial time.</p>
<p><strong>Features:</strong></p>
<ol style="list-style-type:decimal;">
<li>The solutions of the NP class are hard to find since they are being solved by a non-deterministic machine but the solutions are easy to verify.</li>
<li>Problems of NP can be verified by a Turing machine in polynomial time.</li>
</ol>
<p>This class contains many problems that one would like to be able to solve effectively:</p>
<ol style="list-style-type:decimal;">
<li><strong>Boolean Satisfiability Problem (SAT).</strong></li>
<li><strong>Hamiltonian Path Problem.</strong></li>
<li><strong>Graph coloring.</strong></li>
</ol>
<p><strong><u>NP-complete class</u></strong></p>
<p>A problem is NP-complete if it is both NP and NP-hard. NP-complete problems are the hard problems in NP.</p>
<p><strong>Features:</strong></p>
<ol style="list-style-type:decimal;">
<li>NP-complete problems are special as any problem in NP class can be transformed or reduced into NP-complete problems in polynomial time.</li>
<li>If one could solve an NP-complete problem in polynomial time, then one could also solve any NP problem in polynomial time.</li>
</ol>
<p>Some example problems include:</p>
<ol style="list-style-type:decimal;">
<li><strong>Decision version of 0/1 Knapsack.</strong></li>
<li><strong>Hamiltonian Cycle.</strong></li>
<li><strong>Satisfiability.</strong></li>
<li><strong>Vertex cover.</strong></li>
</ol>
</div>
<h3>Question 11</h3>
<div><p><p>Find the optimal parenthesization for the matrix chain product ABCD with size of each is given as A<sub>5×10 </sub>, B<sub>10×15</sub> , C<sub>15×20</sub> , D<sub>20×30</sub></p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p>To find the optimal parenthesization for the matrix chain product ABCD with given sizes, you can use dynamic programming to minimize the number of scalar multiplications. The goal is to find the optimal way to parenthesize the matrices to minimize the overall cost.</p>
<p>Let’s denote the matrices as follows:</p>
<ul style="list-style-type: square;">
<li>A: 5×10</li>
<li>B: 10×15</li>
<li>C: 15×20</li>
<li>D: 20×30</li>
</ul>
<p>given,</p>
<p style="text-align: center;"><img data-recalc-dims="1" loading="lazy" decoding="async" class="alignnone size-full wp-image-39992" src="https://i0.wp.com/hamrocsit.com/wp-content/uploads/2024/08/matrix-chain.drawio.png?resize=199%2C123&#038;ssl=1" alt="" width="199" height="123"></p>
<p><strong>PASS 1:</strong></p>
<p>M[A, B] = A * B</p>
<p>= 5 * 10 *15</p>
<p>= 750</p>
<p>M[B, C] = B * C</p>
<p>= 10 * 15 * 20</p>
<p>= 3000</p>
<p>M[C, D] = C * D</p>
<p>= 15 * 20 * 30</p>
<p>= 9000</p>
<p>&nbsp;</p>
<p><strong>PASS 2:</strong></p>
<p>M[A, C] = A * B * C</p>
<p>= min{M[A, A]+M[B, C]+P<sub>0</sub>P<sub>1</sub>P<sub>2</sub>,  M[A, B]+M[C, C]+P<sub>0</sub>P<sub>2</sub>P<sub>3</sub>}</p>
<p>= min{0 + 3000 + 5*10*20,   50 + 0 + 5*15*20}</p>
<p>= min{4000,   2250}</p>
<p>= 2250</p>
<p>M[B, D] = B * C* D</p>
<p>= min{M[B, B]+M[C, D]+P<sub>1</sub>P<sub>2</sub>P<sub>4</sub>,  M[B, C]+M[D, D]+P<sub>1</sub>P<sub>3</sub>P<sub>4</sub>}</p>
<p>= min{0 + 9000 + 10*15*30,   3000 + 0 + 10*20*30}</p>
<p>= min{13500,   9000}</p>
<p>= 9000</p>
<p>&nbsp;</p>
<p><strong>PASS 3:</strong></p>
<p>M[A, D] = A * B * C * D</p>
<p>= min{M[A, A]+M[B, D]+P<sub>0</sub>P<sub>1</sub>P<sub>4</sub>,  M[A, B]+M[C, C]+P<sub>0</sub>P<sub>2</sub>P<sub>4</sub>,                                   M[A, C]+M[D, D]+P<sub>0</sub>P<sub>3</sub>P<sub>4</sub>}</p>
<p>= min{0+9000+5*10*30,  750+9000+5*15*30,                                                              2250+0+5*20*30}</p>
<p>= min{10500, 12000, 5250 }</p>
<p>= 5250</p>
<p>Optimal Paranthesization:</p>
<p><img data-recalc-dims="1" loading="lazy" decoding="async" class="alignnone size-full wp-image-39993 aligncenter" src="https://i0.wp.com/hamrocsit.com/wp-content/uploads/2024/08/OPTIML-PARENTHESIS.drawio.png?resize=258%2C188&#038;ssl=1" alt="" width="258" height="188"></p>
<p style="text-align: center;">i.e ( ( A * B) * C ) * D)</p>
</div>
<h3>Question 12</h3>
<div><p><p>Write short notes on:<br />
a) Best, Worst and average case complexity</p>
<p>b) Backtracking strategy</p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p>a)<strong> Best-case complexity</strong> :</p>
<p>Best case time complexity refers to the minimum number of operation an algorithm needs to perform for the specific input. It is the most favourable situation for algorithm execution.</p>
<p>Worst-case complexity : Worst case time complexity refers to the maximum number of operation an algorithm needs to perform for the specific input. It is the least favourable situation for algorithm execution.</p>
<p data-sourcepos="11:3-11:296">Average-case complexity : The average-case complexity of an algorithm represents the average amount of resources it requires to run over all possible inputs. It takes into account the frequency of different input scenarios to provide a more realistic estimate of the algorithm’s performance.</p>
<p data-sourcepos="11:3-11:296">b) <strong>Backtracking </strong>:</p>
<p>Backtracking is a technique based on algorithm to solve problem. It uses recursive calling to find the solution by building a solution step by step increasing values with time. It removes the solutions that doesn’t give rise to the solution of the problem based on the constraints given to solve the problem.</p>
<p>Backtracking algorithm is applied to some specific types of problems,</p>
<ul class="list">
<li>Decision problem used to find a feasible solution of the problem.</li>
<li>Optimisation problem used to find the best solution that can be applied.</li>
<li>Enumeration problem used to find the set of all feasible solutions of the problem.</li>
</ul>
<p>In backtracking problem, the algorithm tries to find a sequence path to the solution which has some small checkpoints from where the problem can backtrack if no feasible solution is found for the problem.</p>
</div>
</body></html>