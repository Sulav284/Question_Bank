
    <html>
    <head>
        <meta charset="UTF-8">
        <title>DAA Question Bank 2080 2080</title>
    </head>
    <body>
        <h1>DAA Question Bank 2080 - 2080</h1>
        <p><strong>Full Marks:</strong> 60 + 20 + 20</p>
        <p><strong>Pass Marks:</strong> 24 + 8 + 8</p>
        <p><strong>Time:</strong> 3 hours</p>
    <h2>Section A: Attempt any two questions.</h2><h3>Question 1</h3>
<div><p><p>What is recurrence relation? How it can be solved? Show that time complexity of the recurrence relation T(n) = 2T(n/2) + 1 is O(n) using substitution method.</p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p>A <strong>recurrence relation</strong> is a mathematical equation that defines a sequence based on its previous terms. In other words, it describes the relationship between the terms of a sequence by expressing each term in terms of one or more preceding terms.</p>
<p>There are several methods to solve recurrence relations:</p>
<ol style="list-style-type:decimal;">
<li><strong>Substitution method:</strong> This involves guessing a solution and then proving it by induction. You assume that the solution has a certain form and then prove that it satisfies the recurrence relation.</li>
<li><strong>Recurrence tree method:</strong> This method is often used for divide-and-conquer algorithms. You create a tree representing the recurrence relation and then analyze the total work done by summing up the contributions from each level.</li>
<li><strong>Iteration method: </strong>This method involves substituing the value of recurrence relation onto its smaller instances. A relation is derived at each level from which a pattern and a stopping condition is generated.</li>
<li><strong>Master theorem (for divide-and-conquer algorithms):</strong> The master theorem is a specific method for solving recurrence relations that arise in the analysis of divide-and-conquer algorithms. It provides solutions for recurrences of a specific form.</li>
</ol>
<p>&nbsp;</p>
<p><img data-recalc-dims="1" loading="lazy" decoding="async" class="alignnone  wp-image-29493" src="https://i0.wp.com/hamrocsit.com/wp-content/uploads/2024/01/SmartSelect_20240128_211914_CamScanner.jpg?resize=555%2C880&#038;ssl=1" alt="" width="555" height="880"><img data-recalc-dims="1" loading="lazy" decoding="async" class="alignnone  wp-image-29492" src="https://i0.wp.com/hamrocsit.com/wp-content/uploads/2024/01/SmartSelect_20240128_211940_CamScanner.jpg?resize=555%2C814&#038;ssl=1" alt="" width="555" height="814"></p>
</div>
<h3>Question 2</h3>
<div><p><p>Write down the advantages of dynamic programming over greedy strategy. Find optimal bracketing to multiply 4 matrices of order 2,3,4,2,5.</p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p>Advantages of dynamic programming over a greedy strategy:</p>
<ol style="list-style-type:decimal;">
<li><strong>Optimality:</strong> Dynamic programming guarantees finding the globally optimal solution. It systematically considers all possible solutions and avoids making choices that might lead to suboptimal solutions. Greedy algorithms, on the other hand, make locally optimal choices at each step and may not always lead to a globally optimal solution.</li>
<li><strong>Structure of Optimal Solution:</strong> Dynamic programming often breaks down a complex problem into smaller overlapping subproblems. By solving these subproblems and storing their solutions, dynamic programming can efficiently reconstruct the optimal solution to the original problem. This is especially useful when the structure of the optimal solution involves optimal solutions to subproblems. Greedy algorithms may not have the same ability to exploit such a structure.</li>
<li><strong>Subproblem Elimination:</strong> Dynamic programming typically involves solving subproblems and storing their solutions in a table, which can be referred to when needed. This eliminates redundant computations and ensures that each subproblem is solved only once. Greedy algorithms may lack this property and might solve similar subproblems multiple times.</li>
<li><strong>Applicability to a Wider Range of Problems:</strong> Dynamic programming is more versatile and applicable to a broader range of problems. It can be used for problems with optimal substructure and overlapping subproblems, making it suitable for various scenarios. Greedy algorithms are generally simpler and more intuitive but are limited in their applicability.</li>
<li><strong>Flexibility in Choices:</strong> Dynamic programming allows for more flexibility in making choices. At each step, dynamic programming algorithms may consider various options and choose the one that leads to the optimal solution. Greedy algorithms, in contrast, make immediate locally optimal choices and may not consider the global consequences of those choices.</li>
<li><strong>Adaptability to Different Objectives:</strong> Dynamic programming is well-suited for optimization problems with different types of objectives, including minimization and maximization. It can be applied to problems involving various criteria and constraints. Greedy algorithms may be less adaptable to changing objectives or constraints.</li>
</ol>
<p><img data-recalc-dims="1" loading="lazy" decoding="async" class="alignnone  wp-image-29496" src="https://i0.wp.com/hamrocsit.com/wp-content/uploads/2024/01/SmartSelect_20240128_212124_CamScanner.jpg?resize=555%2C810&#038;ssl=1" alt="" width="555" height="810"><img data-recalc-dims="1" loading="lazy" decoding="async" class="alignnone  wp-image-29495" src="https://i0.wp.com/hamrocsit.com/wp-content/uploads/2024/01/SmartSelect_20240128_212152_CamScanner.jpg?resize=555%2C991&#038;ssl=1" alt="" width="555" height="991"></p>
</div>
<h3>Question 3</h3>
<div><p><p>Discuss heapify operation with example. Write down its algorithm and analyze its time and space complexity.</p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p><strong>Heapify operation</strong></p>
<p>Heapify is an operation performed on a binary heap data structure to maintain its heap property. A binary heap is a complete binary tree where the value of each node is less than or equal to (for max heap) or greater than or equal to (for min heap) the values of its children. Heapify ensures that the heap property is satisfied, and it is commonly used in operations like inserting an element into a heap or extracting the minimum/maximum element.</p>
<p>Example:</p>
<p>Consider the array arr = [4, 10, 3, 5, 1]. Let&#8217;s heapify this array using the given algorithm:</p>
<p>1. Start with the last non-leaf node (in this case, index 1, as the last non-leaf node is at floor((n-1)/2), where n is the number of elements).</p>
<p>2. Compare the root of the subtree (at index 1) with its children (at indices 3 and 4).</p>
<p style="text-align: left;">arr = [4, 10, 3, 5, 1]<br />
4<br />
/   \<br />
10    3<br />
/  \<br />
5    1</p>
<p style="text-align: left;">3. Swap the root (4) with the largest child (10).</p>
<p>arr = [4, 10, 3, 5, 1]<br />
10<br />
/   \<br />
4     3<br />
/  \<br />
5    1</p>
<p>4. Recursively apply the heapify operation to the affected subtree rooted at index 3.</p>
<p>arr = [4, 10, 3, 5, 1]<br />
10<br />
/   \<br />
5     3<br />
/  \<br />
4    1</p>
<p>Now, the array satisfies the max heap property.</p>
<p><strong>Algorithm for Heapify</strong></p>
<p>Heapify(arr, n, i):<br />
largest = i<br />
left_child = 2 * i + 1<br />
right_child = 2 * i + 2</p>
<p># Check if the left child exists and is greater than the current largest<br />
if left_child &lt; n and arr[left_child] &gt; arr[largest]:<br />
largest = left_child</p>
<p># Check if the right child exists and is greater than the current largest<br />
if right_child &lt; n and arr[right_child] &gt; arr[largest]:<br />
largest = right_child</p>
<p># If the largest is not the current root, swap the root with the largest<br />
if largest != i:<br />
swap(arr[i], arr[largest])</p>
<p># Recursively heapify the affected subtree<br />
Heapify(arr, n, largest)</p>
<p><strong>Time Complexity:</strong></p>
<p>The time complexity of the Heapify operation is O(log n), where n is the number of elements in the heap.</p>
<p>This complexity arises because the height of a binary heap is log n, and in each recursive call of Heapify, we move down the tree by one level.</p>
<p><strong>Space Complexity:</strong></p>
<p>The space complexity of Heapify is O(1) as it operates in-place, without requiring additional space. proportional to the input size.</p>
</div>
<h2>Section B: Attempt any eight questions</h2><h3>Question 4</h3>
<div><p><p>Define RAM model. Write down iterative algorithm for finding factorial and provide its detailed analysis.</p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p>The <strong>Random Access Machine (RAM) model</strong> is an abstract computer model that serves as a theoretical foundation for algorithm analysis. In the RAM model, computation occurs in discrete steps, and the main memory is organized into a sequence of cells, each containing a single piece of data. The RAM model assumes that accessing any memory cell takes a constant amount of time, and it supports basic operations such as arithmetic operations, comparisons, and control flow (conditionals and loops).</p>
<p><strong>Factorial algorithm</strong></p>
<p>Factorial(n):<br />
result = 1<br />
for i from 1 to n:<br />
result = result * i<br />
return result</p>
<h3>Analysis:</h3>
<p><strong>Time Complexity:</strong></p>
<p>The loop runs for n iterations, where <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathnormal">n</span></span></span></span></span> is the input to the factorial function. Each iteration involves a constant amount of work (multiplication and assignment). Therefore, the time complexity is <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathnormal">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>.</p>
<p><strong>Space Complexity:</strong></p>
<p>The space complexity is <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathnormal">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span> because the algorithm uses a constant amount of extra space to store the result and loop control variables.</p>
</div>
<h3>Question 5</h3>
<div><p><p>Write down algorithm of insertion sort and analyze its time and space complexity.</p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p><strong>Algorithm</strong></p>
<p>InsertionSort(arr):<br />
n = length of arr</p>
<p>for i from 1 to n-1:<br />
key = arr[i]<br />
j = i &#8211; 1</p>
<p># Move elements of arr[0..i-1] that are greater than key to one position ahead of their current position<br />
while j &gt;= 0 and arr[j] &gt; key:<br />
arr[j + 1] = arr[j]<br />
j = j &#8211; 1</p>
<p>arr[j + 1] = key</p>
<p><strong>Time Complexity:</strong></p>
<ul style="list-style-type: square;">
<li style="list-style-type: none;">
<ul style="list-style-type: square;">
<li>In the worst-case scenario, where the input array is in reverse order, each element must be compared and moved to its correct position in each iteration of the outer loop.</li>
<li>The worst-case time complexity is <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathnormal">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n<sup>2</sup></span></span><span class="mclose">)</span></span></span></span></span>, where <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathnormal">n</span></span></span></span></span> is the number of elements in the array.</li>
<li>In the best-case scenario, where the input array is already sorted, the algorithm has a linear time complexity of <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathnormal">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>.</li>
</ul>
</li>
</ul>
<p><strong>Space Complexity:</strong></p>
<p>The space complexity is <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathnormal">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span> because insertion sort operates in-place. It uses only a constant amount of extra space for the key and loop control variables.</p>
</div>
<h3>Question 6</h3>
<div><p><p>Write down minmax algorithm and analyze its complexity.</p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p><strong>Minmax algorithm</strong></p>
<p>def min(a, b):<br />
return a if a &lt; b else b</p>
<p>def max(a, b):<br />
return a if a &gt; b else b</p>
<p>def MinMax(arr, left, right):<br />
# Base case: If the subarray has only one element<br />
if left == right:<br />
return (arr[left], arr[left])<br />
# Base case: If the subarray has two elements<br />
elif right == left + 1:<br />
return (min(arr[left], arr[right]), max(arr[left], arr[right]))<br />
else:<br />
# Divide the array into two halves<br />
mid = (left + right) // 2</p>
<p># Recursively find the minimum and maximum in each half<br />
(min_left, max_left) = MinMax(arr, left, mid)<br />
(min_right, max_right) = MinMax(arr, mid + 1, right)</p>
<p># Combine the results to find the overall minimum and maximum<br />
overall_min = min(min_left, min_right)<br />
overall_max = max(max_left, max_right)</p>
<p>return (overall_min, overall_max)</p>
<p><strong>Time Complexity:</strong></p>
<p>The time complexity of the MinMax algorithm is <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathnormal">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>, where <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathnormal">n</span></span></span></span></span> is the number of elements in the array. This is because the algorithm recursively divides the array into halves and performs constant-time operations for each element during the recursion.</p>
<ul style="list-style-type: square;">
<li>At each level of recursion, the algorithm visits each element of the array exactly once.</li>
<li>The total number of recursive calls is <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathnormal">O</span><span class="mopen">(</span><span class="mop">log</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> in the worst case, where <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathnormal">n</span></span></span></span></span> is the number of elements.</li>
<li>Each element is visited <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathnormal">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span> times per recursive call.</li>
</ul>
<p>Hence, the overall time complexity is <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathnormal">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>.</p>
<p><strong>Space Complexity:</strong></p>
<p>The space complexity of the MinMax algorithm is <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathnormal">O</span><span class="mopen">(</span><span class="mop">log</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>, which is determined by the depth of the recursion stack.</p>
<ul style="list-style-type: square;">
<li>In each recursive call, the algorithm stores constant information (such as left and right indices) on the call stack.</li>
<li>The maximum depth of the recursion is <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathnormal">O</span><span class="mopen">(</span><span class="mop">log</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> in the worst case, where <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathnormal">n</span></span></span></span></span> is the number of elements in the array.</li>
</ul>
<p>Therefore, the overall space complexity is <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathnormal">O</span><span class="mopen">(</span><span class="mop">log</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>.</p>
</div>
<h3>Question 7</h3>
<div><p><p>When greedy strategy provides optimal solution? Write down job sequencing with deadlines algorithm and analyze its complexity.</p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p>A greedy strategy provides an optimal solution in algorithmic problems when it exhibits both the &#8220;greedy-choice property&#8221; and &#8220;optimal substructure.&#8221;</p>
<ol style="list-style-type:decimal;">
<li><strong>Greedy-Choice Property:</strong> A globally optimal solution can be arrived at by selecting a locally optimal choice at each step.</li>
<li><strong>Optimal Substructure:</strong> An optimal solution to the problem contains optimal solutions to its subproblems.</li>
</ol>
<p><strong>Job sequencing with deadline algorithm</strong></p>
<p>JobSequencingWithDeadline(D,J,n,k)</p>
<p>{</p>
<p>D(0)=J(0)=0</p>
<p>k=1</p>
<p>J(1)=1  //first job is selected</p>
<p>for i = 2 &#8230;. n do</p>
<p>r=k</p>
<p>while D(J(r)&gt;D(i) and D(J(r)) ≠ r do</p>
<p>r = r-1</p>
<p>if D(J(r)) ≤ D(i) and D(i) &gt; r then</p>
<p>for l = k&#8230;. r+1 by -1 do</p>
<p>J(l+1)=J(l)</p>
<p>J(r+1)=i</p>
<p>k=k+1</p>
<p>}</p>
<p><strong>Analysis</strong></p>
<p>Complexity of this algorithm is O(n<sup>2</sup>) because of the use of two loops.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
</div>
<h3>Question 8</h3>
<div><p><p>Suppose that a message contains alphabet frequencies as given below and find Huffman codes for each alphabet</p>
<div class="table_wrapper"><table>
<tbody>
<tr>
<td><strong>Symbol</strong></td>
<td><strong>Frequency</strong></td>
</tr>
<tr>
<td>a</td>
<td>30</td>
</tr>
<tr>
<td>b</td>
<td>20</td>
</tr>
<tr>
<td>c</td>
<td>25</td>
</tr>
<tr>
<td>d</td>
<td>15</td>
</tr>
<tr>
<td>e</td>
<td>35</td>
</tr>
</tbody>
</table></div</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p><img data-recalc-dims="1" loading="lazy" decoding="async" class="alignnone  wp-image-29504" src="https://i0.wp.com/hamrocsit.com/wp-content/uploads/2024/01/SmartSelect_20240128_212219_CamScanner.jpg?resize=555%2C564&#038;ssl=1" alt="" width="555" height="564"><img data-recalc-dims="1" loading="lazy" decoding="async" class="alignnone  wp-image-29503" src="https://i0.wp.com/hamrocsit.com/wp-content/uploads/2024/01/SmartSelect_20240128_212240_CamScanner.jpg?resize=553%2C320&#038;ssl=1" alt="" width="553" height="320"></p>
</div>
<h3>Question 9</h3>
<div><p><p>Does backtracking give multiple solution? Trace subset sum algorithm for the set {3,5,2,4,1} andd sum=8.</p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p>Whether backtracking gives multiple solutions depends on how it is implemented for a specific problem:</p>
<ol style="list-style-type:decimal;">
<li><strong>Finding a Single Solution:</strong>
<ul style="list-style-type: square;">
<li>In some cases, the backtracking algorithm may be designed to find only one solution. Once a valid solution is found, the algorithm stops its search and returns that solution.</li>
<li>For example, in solving the N-Queens problem, the goal might be to find just one placement of queens on a chessboard such that no two queens attack each other.</li>
</ul>
</li>
<li><strong>Finding All Solutions:</strong>
<ul style="list-style-type: square;">
<li>In other cases, the backtracking algorithm may be modified to find all possible solutions. The algorithm continues its search even after finding a solution and explores the entire solution space.</li>
<li>Backtracking can be adapted to find multiple solutions by backtracking to the previous decision point after finding a solution and continuing the search for additional solutions.</li>
<li>For example, in solving the subset sum problem, where the goal is to find all subsets of a set that sum to a particular value, backtracking can be used to enumerate all such subsets.</li>
</ul>
</li>
</ol>
<p><strong>Solution of the numeric:</strong></p>
<p><img data-recalc-dims="1" loading="lazy" decoding="async" class="alignnone  wp-image-29506" src="https://i0.wp.com/hamrocsit.com/wp-content/uploads/2024/01/SmartSelect_20240128_212313_CamScanner.jpg?resize=556%2C328&#038;ssl=1" alt="" width="556" height="328"></p>
</div>
<h3>Question 10</h3>
<div><p><p>Why extended euclidean algorithm is used? Write down its algorithm and analyze its complexity.</p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p>The <strong>Extended Euclidean Algorithm</strong> is commonly used for several purposes in number theory and cryptography. Its main applications include:</p>
<ol style="list-style-type:decimal;">
<li><strong>Computing the Multiplicative Inverse:</strong>
<ul style="list-style-type: square;">
<li>One of the primary uses of the Extended Euclidean Algorithm is to find the multiplicative inverse of an integer <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathnormal">a</span></span></span></span></span> modulo <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathnormal">m</span></span></span></span></span>, where <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathnormal">a</span></span></span></span></span> and <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathnormal">m</span></span></span></span></span> are integers and <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathnormal">m</span><span class="mrel">&gt;</span></span><span class="base"><span class="mord">1</span></span></span></span></span>. The multiplicative inverse of <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathnormal">a</span></span></span></span></span> modulo <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathnormal">m</span></span></span></span></span> is an integer <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathnormal">x</span></span></span></span></span> such that <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mrel">≡</span></span><span class="base"><span class="mord">1</span></span><span class="base"><span class="mopen">(</span><span class="mord"><span class="mord mathrm">mod</span></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span>. This is particularly useful in modular arithmetic and cryptography.</li>
</ul>
</li>
<li><strong>Solving Linear Diophantine Equations:</strong>
<ul style="list-style-type: square;">
<li>The algorithm can be applied to solve linear Diophantine equations of the form <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mbin">+</span></span><span class="base"><span class="mord mathnormal">b</span><span class="mord mathnormal">y</span><span class="mrel">=</span></span><span class="base"><span class="mord mathnormal">c</span></span></span></span></span>, where <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathnormal">a</span></span></span></span></span>, <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathnormal">b</span></span></span></span></span>, and <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathnormal">c</span></span></span></span></span> are integers. The algorithm finds solutions <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathnormal">x</span></span></span></span></span> and <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathnormal">y</span></span></span></span></span> when they exist.</li>
</ul>
</li>
<li><strong>Calculating the Greatest Common Divisor (gcd):</strong>
<ul style="list-style-type: square;">
<li>While the standard Euclidean Algorithm efficiently calculates the greatest common divisor of two integers, the Extended Euclidean Algorithm goes a step further by providing Bézout coefficients (<span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathnormal">x</span></span></span></span></span> and <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathnormal">y</span></span></span></span></span>) that satisfy <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mbin">+</span></span><span class="base"><span class="mord mathnormal">b</span><span class="mord mathnormal">y</span><span class="mrel">=</span></span><span class="base"><span class="mop">gcd</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mord mathnormal">b</span><span class="mclose">)</span></span></span></span></span>.</li>
</ul>
</li>
</ol>
<p><strong>Algorithm</strong></p>
<p>ExtendedEuclidean(a, b):<br />
if b = 0:<br />
return (a, 1, 0)<br />
else:<br />
(d, x, y) = ExtendedEuclidean(b, a mod b)<br />
return (d, y, x &#8211; floor(a / b) * y)]</p>
<p><strong>Complexity Analysis:</strong></p>
<p>The time complexity of the Extended Euclidean Algorithm is <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathnormal">O</span><span class="mopen">(</span><span class="mop">log</span><span class="mopen">(</span><span class="mop">min</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mord mathnormal">b</span><span class="mclose">)))</span></span></span></span></span>, where <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathnormal">a</span></span></span></span></span> and <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathnormal">b</span></span></span></span></span> are the input integers. The algorithm&#8217;s efficiency is because, at each step, the size of the numbers involved is reduced significantly. The number of iterations is proportional to the number of bits in the smaller of the two numbers.</p>
<p>The space complexity is <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathnormal">O</span><span class="mopen">(</span><span class="mop">log</span><span class="mopen">(</span><span class="mop">min</span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mord mathnormal">b</span><span class="mclose">)))</span></span></span></span></span> due to the recursive calls. The algorithm uses a constant amount of additional memory for each recursion level.</p>
</div>
<h3>Question 11</h3>
<div><p><p>Define NP-complete problems with examples. Give brief proof of the statement “SAT is NP-complete”.</p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p><strong>NP-complete</strong> problems is a complexity class that represents the set of all problems X in NP to which it is possible to reduce any other NP problem Y to X in polynomial time.</p>
<p>A decision problem L is NP-complete if:</p>
<ul style="list-style-type: square;">
<li>L is in NP</li>
<li>Every problem in Np is reducible to L in polynomial time.</li>
</ul>
<p>Examples: SAT, Knapsack problem, Hamiltonian path problem, Clique problem, Subset sum problem, Vertex cover problem, etc.</p>
<p><strong>Proof that SAT is NP-complete</strong></p>
<p>To prove SAT is NP-complete, we have to prove 2 properties:</p>
<ul style="list-style-type: square;">
<li>SAT is NP.</li>
<li>SAT is NP-hard.</li>
</ul>
<p><strong>To show &#8220;SAT is NP&#8221;</strong></p>
<p>SAT : &#8220;Given a Boolean combinational circuit, is it satisfiable?&#8221;</p>
<p>Given circuit satisfiability problem, take a circuit x and certificate y with the set of values that produces output 1, we can verify that whether given ceritificate satisfies the circuit in polynomial time. So, SAT is NP.</p>
<p><strong>To show &#8220;SAT is NP hard&#8221;</strong></p>
<p>Take a problem V that is NP. Let A be algorithm that verifies V in polynomial time. This is true because V is NP. We can program A on computer therefore, there exists a logical circuit whose input wires correspond to bits of the inputs x and y of A and which outputs 1 precisely when A(x,y) returns yes.</p>
<p>For any instance x of V let Ax be the circuit obtained from A by setting x input wire values according to specific string x. The construction of Ax from x is our reduction function. If x is a yes instance of V then the certificate y for x gives satisfying assignments for Ax. Conversely, if Ax outputs 1 for some assignments to its input wires, that assignment translates into a certificate for x.</p>
<p>&nbsp;</p>
</div>
<h3>Question 12</h3>
<div><p><p>Write short notes on</p>
<p>a) Aggregate Analysis</p>
<p>b) Selection problems</p</p></div><div><strong>Answer:</strong><br><style>body .mathjax_wrap{width: 100%;overflow-x: scroll;margin-bottom:10px;}</style><p><strong>a. Aggregate analysis</strong></p>
<p>It is one of the techniques used in amortized analysis, focusing on the total cost of a sequence of operations and then averaging it over all the operations.</p>
<p>Key points:</p>
<p><strong>1. Total Cost and Average Cost</strong></p>
<p>Aggregate analysis considers the total cost of a sequence of operations rather than individual operation costs. It aims to understand the average cost per operation over the entire sequence.</p>
<p><strong>2. Amortized Cost:</strong></p>
<p>The amortized cost of an operation is the average cost per operation over a sequence of operations. It provides a more realistic and meaningful measure of the algorithm&#8217;s performance.</p>
<p><strong>Example &#8211; Dynamic Arrays:</strong></p>
<p>Consider the example of dynamic arrays that occasionally need to resize. The resizing operation has a high cost but is infrequent. Aggregate analysis helps spread the cost of resizing over all the insertions, resulting in an average cost per insertion that is much lower than the actual resizing cost.</p>
<p>Let&#8217;s use the dynamic array example to illustrate aggregate analysis:</p>
<ul style="list-style-type: square;">
<li><strong>Operation Sequence:</strong>
<ol style="list-style-type:decimal;">
<li>Perform <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathnormal">n</span></span></span></span></span> insertions.</li>
<li>Resize the array when necessary.</li>
</ol>
</li>
<li><strong>Actual Cost:</strong>
<ul style="list-style-type: square;">
<li>Resizing takes <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathnormal">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> time.</li>
</ul>
</li>
<li><strong>Aggregate Analysis:</strong>
<ul style="list-style-type: square;">
<li>Total cost is <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathnormal">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mbin">+</span></span><span class="base"><span class="mord mathnormal">n</span><span class="mbin">⋅</span></span><span class="base"><span class="mord mathnormal">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mrel">=</span></span><span class="base"><span class="mord mathnormal">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>.</li>
<li>Average cost per insertion is <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathnormal">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathnormal">n</span><span class="mrel">=</span></span><span class="base"><span class="mord mathnormal">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>.</li>
</ul>
</li>
</ul>
<p>Aggregate analysis allows us to state that, on average, each insertion operation has an amortized cost of <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="mord mathnormal">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span>, even though some insertions trigger a more expensive resizing operation.</p>
<p>&nbsp;</p>
<p><strong>b. Selection problems</strong></p>
<p>Selection problems refer to a class of computational problems where the goal is to find the k-th smallest or largest element in a set of data. The term &#8220;selection&#8221; is often associated with finding the k-th order statistic.</p>
<p>Key points:</p>
<ul style="list-style-type: square;">
<li><strong>Order Statistics:</strong> Selection problems deal with finding the k-th order statistic, which is the k-th smallest or largest element in a set.</li>
<li><strong>Common Variants:</strong> Two common variants are:
<ol style="list-style-type:decimal;">
<li><strong>kth Smallest/Largest Element:</strong> Find the k-th smallest or largest element in an unsorted array.</li>
<li><strong>Partial Sorting:</strong> Partially sort the data to get the k smallest or largest elements.</li>
</ol>
</li>
<li><strong>Algorithms:</strong> Various algorithms are designed to solve selection problems efficiently, including randomized algorithms like QuickSelect and deterministic algorithms like the median of medians algorithm.</li>
<li><strong>Applications:</strong> Selection problems have applications in various fields, such as statistics, databases, and algorithms dealing with large datasets.</li>
<li><strong>Example:</strong> Given an unsorted array, finding the median (k = n/2) or the minimum/maximum (k = 1 or k = n) are common examples of selection problems.</li>
</ul>
</div>
</body></html>